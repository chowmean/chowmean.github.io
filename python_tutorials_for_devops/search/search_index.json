{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Python Training for devops Python is a well known programming language which is used for scripting, data science, software and system development. It is one of the most used language of these days. This training course is for devops people who want to use python in their projects and later use it in a full fledge development. In this course we will talk about OOPS, CLI applications in python, frameworks in python, GIL, memory management, basic tooling around python, etc.","title":"Home"},{"location":"#welcome-to-python-training-for-devops","text":"Python is a well known programming language which is used for scripting, data science, software and system development. It is one of the most used language of these days. This training course is for devops people who want to use python in their projects and later use it in a full fledge development. In this course we will talk about OOPS, CLI applications in python, frameworks in python, GIL, memory management, basic tooling around python, etc.","title":"Welcome to Python Training for devops"},{"location":"cliapp/","text":"Introduction In this part we will be creating a cli application using a well known framework called Click. What you need to start this? Basic knowledge of python syntax loops, how to use packages and how to run python program. Knowledge of cli app will be a good addition. Click package Click is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It\u2019s the \u201cCommand Line Interface Creation Kit\u201d. It\u2019s highly configurable but comes with sensible defaults out of the box. Lets code Create a directory for your project. Then create a requirements.txt file in your directory. After that initialize an empty env for you python project and then run pip install to install the required packages. Here package will be click so put click in your requirements file. All of this is below mkdir project_name cd project_name & & touch requirements.txt virtualenv venv source venv/bin/activate echo \"click\" >> requirements.txt pip install -r requirements.txt Our project directory is ready create a file with any name and start writing the code below. Here we will be creating a very basic cli app which says hello. import click @click.command() def hello(): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" click.echo('Hello') if __name__ == '__main__': hello() Run this using python filename.py and you will see hello as output. Taking arguement in CLI For taking arguement click provide a very easy options. Have a look at code below import click @click.command() @click.option('--name', prompt='Your name', help='The person to greet.') def hello( name): for x in range(): click.echo('Hello %s!' % name) if __name__ == '__main__': hello() Here you can take your name as CLI arguement and then this program will print hello your_name. Run this command to run it. python filename.py youname","title":"Creating a CLI application"},{"location":"cliapp/#introduction","text":"In this part we will be creating a cli application using a well known framework called Click.","title":"Introduction"},{"location":"cliapp/#what-you-need-to-start-this","text":"Basic knowledge of python syntax loops, how to use packages and how to run python program. Knowledge of cli app will be a good addition.","title":"What you need to start this?"},{"location":"cliapp/#click-package","text":"Click is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It\u2019s the \u201cCommand Line Interface Creation Kit\u201d. It\u2019s highly configurable but comes with sensible defaults out of the box.","title":"Click package"},{"location":"cliapp/#lets-code","text":"Create a directory for your project. Then create a requirements.txt file in your directory. After that initialize an empty env for you python project and then run pip install to install the required packages. Here package will be click so put click in your requirements file. All of this is below mkdir project_name cd project_name & & touch requirements.txt virtualenv venv source venv/bin/activate echo \"click\" >> requirements.txt pip install -r requirements.txt Our project directory is ready create a file with any name and start writing the code below. Here we will be creating a very basic cli app which says hello. import click @click.command() def hello(): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" click.echo('Hello') if __name__ == '__main__': hello() Run this using python filename.py and you will see hello as output.","title":"Lets code"},{"location":"cliapp/#taking-arguement-in-cli","text":"For taking arguement click provide a very easy options. Have a look at code below import click @click.command() @click.option('--name', prompt='Your name', help='The person to greet.') def hello( name): for x in range(): click.echo('Hello %s!' % name) if __name__ == '__main__': hello() Here you can take your name as CLI arguement and then this program will print hello your_name. Run this command to run it. python filename.py youname","title":"Taking arguement in CLI"},{"location":"gil/","text":"GIL: Global Interpreter Lock Gil is a mutex lock in python which allows only one thread to execute at a time. This is why python is single threaded application. So if your program is simgle threaded python will perform as equal to any other language. But when it comes to multithreading and executing threads in parallel, it is not possible in python Why GIL? Python uses reference counting for memory management. What it does is it keeps track of all the variables that are created and wheather they are being used in the program now or not. If their is no reference for those variables. The python garbage collector kicks in and removes that variable from the heap. Now for this reference counting to work properly it need to be safe from race conditions. That is two threads try to change the reference count. If that happens that can lead to memory leak. This reference count can be kept safe by locking all the data structures that are shared accross the threads. Now if we lock these data structures. It means multiple locks will exist which can lead to problems like deadlock. Also it will decrease performance as aquisition and release of locks will happen quite frequently. GIL is a single lock which says that execution of any python byte code requires the interpreter lock. This prevents the above problem but makes the python single threaded. Why only GIL as solution? Python has been around since the days when operating systems did not have a concept of threads. Python was designed to be easy-to-use in order to make development quicker and more and more developers started using it. A lot of extensions were being written for the existing C libraries whose features were needed in Python. To prevent inconsistent changes, these C extensions required a thread-safe memory management which the GIL provided. The GIL is simple to implement and was easily added to Python. It provides a performance increase to single-threaded programs as only one lock needs to be managed. C libraries that were not thread-safe became easier to integrate. And these C extensions became one of the reasons why Python was readily adopted by different communities. Impacts? There are two kinds of multithreaded programs. I/O bound program : Programs that wait for input/output from user, file, database, network etc. These sometimes have to wait alot. CPU bound program : These programs are the one which does high computational tasks. We will see how python works in both these cases. In case of CPU bound programs the multithreading will not make any difference as the only one thread will execute. Infact you can see performance degrading for these cases. In case of IO bound process the multithreading will increase performance as IO bound process mostly wait for the input or output to be provided to them and they are in waiting state. Aquiring and releasing lock for these kind of process doesn't cause problem cause when one thread may got the output or input the others may still be waiting for the event. Work around? If you want to make use of all your core in pytho program instead of going for multithreading go for multiprocessing . Each process gets its own python interpretor this the GIL is applied on only that process and hence you can do lot of work in parallel. Read more about GIL here","title":"Global Interpreter Lock"},{"location":"gil/#gil-global-interpreter-lock","text":"Gil is a mutex lock in python which allows only one thread to execute at a time. This is why python is single threaded application. So if your program is simgle threaded python will perform as equal to any other language. But when it comes to multithreading and executing threads in parallel, it is not possible in python","title":"GIL: Global Interpreter Lock"},{"location":"gil/#why-gil","text":"Python uses reference counting for memory management. What it does is it keeps track of all the variables that are created and wheather they are being used in the program now or not. If their is no reference for those variables. The python garbage collector kicks in and removes that variable from the heap. Now for this reference counting to work properly it need to be safe from race conditions. That is two threads try to change the reference count. If that happens that can lead to memory leak. This reference count can be kept safe by locking all the data structures that are shared accross the threads. Now if we lock these data structures. It means multiple locks will exist which can lead to problems like deadlock. Also it will decrease performance as aquisition and release of locks will happen quite frequently. GIL is a single lock which says that execution of any python byte code requires the interpreter lock. This prevents the above problem but makes the python single threaded.","title":"Why GIL?"},{"location":"gil/#why-only-gil-as-solution","text":"Python has been around since the days when operating systems did not have a concept of threads. Python was designed to be easy-to-use in order to make development quicker and more and more developers started using it. A lot of extensions were being written for the existing C libraries whose features were needed in Python. To prevent inconsistent changes, these C extensions required a thread-safe memory management which the GIL provided. The GIL is simple to implement and was easily added to Python. It provides a performance increase to single-threaded programs as only one lock needs to be managed. C libraries that were not thread-safe became easier to integrate. And these C extensions became one of the reasons why Python was readily adopted by different communities.","title":"Why only GIL as solution?"},{"location":"gil/#impacts","text":"There are two kinds of multithreaded programs. I/O bound program : Programs that wait for input/output from user, file, database, network etc. These sometimes have to wait alot. CPU bound program : These programs are the one which does high computational tasks. We will see how python works in both these cases. In case of CPU bound programs the multithreading will not make any difference as the only one thread will execute. Infact you can see performance degrading for these cases. In case of IO bound process the multithreading will increase performance as IO bound process mostly wait for the input or output to be provided to them and they are in waiting state. Aquiring and releasing lock for these kind of process doesn't cause problem cause when one thread may got the output or input the others may still be waiting for the event.","title":"Impacts?"},{"location":"gil/#work-around","text":"If you want to make use of all your core in pytho program instead of going for multithreading go for multiprocessing . Each process gets its own python interpretor this the GIL is applied on only that process and hence you can do lot of work in parallel. Read more about GIL here","title":"Work around?"},{"location":"mem/","text":"Memory Management This concept deals with the way python manages memory, how it assigns memory, how it cleans memory and garbage collect. An OS-specific virtual memory manager carves out a chunk of memory for the Python process. Python uses a portion of the memory for internal use and non-object memory. The other portion is dedicated to object storage (your int, dict, and the like). Garbage Collection Python interpretor keeps the reference count of all the variables, if reference count of any variable becomes 0. That variable is garbage collected. If you want to read more about it read here memory management in python","title":"Memory Management"},{"location":"mem/#memory-management","text":"This concept deals with the way python manages memory, how it assigns memory, how it cleans memory and garbage collect. An OS-specific virtual memory manager carves out a chunk of memory for the Python process. Python uses a portion of the memory for internal use and non-object memory. The other portion is dedicated to object storage (your int, dict, and the like).","title":"Memory Management"},{"location":"mem/#garbage-collection","text":"Python interpretor keeps the reference count of all the variables, if reference count of any variable becomes 0. That variable is garbage collected. If you want to read more about it read here memory management in python","title":"Garbage Collection"},{"location":"oops/","text":"Concept of Object Oriented Programming Objects Everything in python are objects. Even if you initialize a variable with 1. 1 is a object of type int. Classes Classes are combination of variables and functions. Classes define a type of any object. An example of class in below class employee(): __phone_number=\"\" def __init__(name, age): self.name = name self.age = age def get_age(): return self.age def set_age(value): self.age = value def get_name(): return self.name def set_phone(value): self.__phone_number = value This is an example of class, Here we have private variable phone_number, which cannot be ediited by anyone else but functions inside the class. __init () is a constructor which is used to initialize the class. Inheritance The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important feature of Object Oriented Programming. Sub Class: The class that inherits properties from another class is called Sub class or Derived Class. Super Class: The class whose properties are inherited by sub class is called Base Class or Super class. class Employee(): __phone_number=\"0000000000\" def __init__(self, name, age): self.name = name self.age = age def get_age(self): return self.age def set_age(self,value): self.age = value def get_name(self): return self.name def set_phone(self,value): self.__phone_number = value def get_phone(self): return self.__phone_number def set_phone(self, value): self.__phone_number = value class VIP(Employee): def get_phone(self): return \"************\" def get_vip_access(self): return \"access_granted\" if __name__ == '__main__': #Simple Employee emp = Employee(\"gaurav\", 12) print(emp.get_phone()) emp.set_phone(\"89628363**\") print(emp.get_phone()) #Vip employee inherting employee properties vip = VIP(\"Venky\", 54) #Overriden method hides phone number print(vip.get_phone()) #Extra added function. print(vip.get_vip_access()) #This function calls the inherited method. print(vip.get_name()) Encapsulation Encapsulation is a way to hide some of the variables of the class to be not accessible from outside the class. In other languages there are class members like private and protected but in python there is no such concept. Instead you can define a private class member like this class Employee(): __phone_number=\"0000000000\" Here __phone_number is a private class member and cannot be accessible from outside the class. You cannot access this variable like below. a = Employee() a.__phone_number To access these variables you have to write getter and setter function for these. Which can do the basic checks before setting the variables. class Employee(): __phone_number=\"0000000000\" def get_phone(self): return self.__phone_number def set_phone(self, value): self.__phone_number = value Use of Encapsulation? Say you have a class User where you have age and password class members. Here you will not want anyone outside the class to see password. Also you want to apply some check before setting the password. This can be done using this. Look at the code below. class User(): __password=\"\" def __init__(self, name, age): self.name = name self.age = age def set_password(password): if password_check(password): self.__password=password Polymorphism Polymorphism means having many forms. In programming it means that same function names can be used for different types of work. def add(x, y, z = 0): return x + y+z # Driver code print(add(2, 3)) print(add(2, 3, 4)) Here function add has two forms. One is when it takes two arguements where the third one itself is 0. Other is when it takes 3 variables. This is very basic example of polymorphism","title":"Object Oriented Programming"},{"location":"oops/#concept-of-object-oriented-programming","text":"","title":"Concept of Object Oriented Programming"},{"location":"oops/#objects","text":"Everything in python are objects. Even if you initialize a variable with 1. 1 is a object of type int.","title":"Objects"},{"location":"oops/#classes","text":"Classes are combination of variables and functions. Classes define a type of any object. An example of class in below class employee(): __phone_number=\"\" def __init__(name, age): self.name = name self.age = age def get_age(): return self.age def set_age(value): self.age = value def get_name(): return self.name def set_phone(value): self.__phone_number = value This is an example of class, Here we have private variable phone_number, which cannot be ediited by anyone else but functions inside the class. __init () is a constructor which is used to initialize the class.","title":"Classes"},{"location":"oops/#inheritance","text":"The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important feature of Object Oriented Programming. Sub Class: The class that inherits properties from another class is called Sub class or Derived Class. Super Class: The class whose properties are inherited by sub class is called Base Class or Super class. class Employee(): __phone_number=\"0000000000\" def __init__(self, name, age): self.name = name self.age = age def get_age(self): return self.age def set_age(self,value): self.age = value def get_name(self): return self.name def set_phone(self,value): self.__phone_number = value def get_phone(self): return self.__phone_number def set_phone(self, value): self.__phone_number = value class VIP(Employee): def get_phone(self): return \"************\" def get_vip_access(self): return \"access_granted\" if __name__ == '__main__': #Simple Employee emp = Employee(\"gaurav\", 12) print(emp.get_phone()) emp.set_phone(\"89628363**\") print(emp.get_phone()) #Vip employee inherting employee properties vip = VIP(\"Venky\", 54) #Overriden method hides phone number print(vip.get_phone()) #Extra added function. print(vip.get_vip_access()) #This function calls the inherited method. print(vip.get_name())","title":"Inheritance"},{"location":"oops/#encapsulation","text":"Encapsulation is a way to hide some of the variables of the class to be not accessible from outside the class. In other languages there are class members like private and protected but in python there is no such concept. Instead you can define a private class member like this class Employee(): __phone_number=\"0000000000\" Here __phone_number is a private class member and cannot be accessible from outside the class. You cannot access this variable like below. a = Employee() a.__phone_number To access these variables you have to write getter and setter function for these. Which can do the basic checks before setting the variables. class Employee(): __phone_number=\"0000000000\" def get_phone(self): return self.__phone_number def set_phone(self, value): self.__phone_number = value","title":"Encapsulation"},{"location":"oops/#use-of-encapsulation","text":"Say you have a class User where you have age and password class members. Here you will not want anyone outside the class to see password. Also you want to apply some check before setting the password. This can be done using this. Look at the code below. class User(): __password=\"\" def __init__(self, name, age): self.name = name self.age = age def set_password(password): if password_check(password): self.__password=password","title":"Use of Encapsulation?"},{"location":"oops/#polymorphism","text":"Polymorphism means having many forms. In programming it means that same function names can be used for different types of work. def add(x, y, z = 0): return x + y+z # Driver code print(add(2, 3)) print(add(2, 3, 4)) Here function add has two forms. One is when it takes two arguements where the third one itself is 0. Other is when it takes 3 variables. This is very basic example of polymorphism","title":"Polymorphism"},{"location":"syntax/","text":"About python Blocks in python While in most of the langauges blocks are defined using brackets like {}, (), [] but in python blocks are defined using spaces that is the piece of code that has the same spaces from the start of line belong to that contiguous block. Example: for(int i=0;i < =20;i++){ //block start console.log(i) } //block end This is javascript example of printing number from one to 20 i=0 while i < =20: #block start print(i) #block end This is python style of the same. Why are Blocks important? Blocks are important because variables scoping depends a lot on them. Variable defined inside a block will only be accessible from inside the block only. Variables Python Variable Name Rules Must begin with a letter (a - z, A - B) or underscore (_) Other characters can be letters, numbers or _ Case Sensitive Can be any (reasonable) length There are some reserved words which you cannot use as a variable name because Python uses them for other things. Good Variable Name Choose meaningful name instead of short name. roll_no is better than rn. Maintain the length of a variable name. Roll_no_of_a-student is too long? Be consistent; roll_no or RollNo Begin a variable name with an underscore(_) character for a special case. Since python in not static typed language you do not need to define the type of variables. Loops For i=0 for i < 10: print(i) i++ While i=0 while i < 10: print(i) i++ Loop through objects a = [1,2,3,4,5,6,7] for i in a: print(i) a=[{\"name\":\"qw\"},{\"name\":\"qwe\"}] for i in a: print(a[\"name\"]) Functions def function_add(var1, var2, var3): do_some_work return var1+var2+var3 Default arguements in functions def function_default_arg(var1, var2, var3=10): return var1+var2+var3 Here if no value is specified for var3 it will be 10 by default so you can call it like below. It also shows us a form of polymorphism which we will see later in this tutorial.","title":"Python Syntax"},{"location":"syntax/#about-python","text":"","title":"About python"},{"location":"syntax/#blocks-in-python","text":"While in most of the langauges blocks are defined using brackets like {}, (), [] but in python blocks are defined using spaces that is the piece of code that has the same spaces from the start of line belong to that contiguous block. Example: for(int i=0;i < =20;i++){ //block start console.log(i) } //block end This is javascript example of printing number from one to 20 i=0 while i < =20: #block start print(i) #block end This is python style of the same.","title":"Blocks in python"},{"location":"syntax/#why-are-blocks-important","text":"Blocks are important because variables scoping depends a lot on them. Variable defined inside a block will only be accessible from inside the block only.","title":"Why are Blocks important?"},{"location":"syntax/#variables","text":"","title":"Variables"},{"location":"syntax/#python-variable-name-rules","text":"Must begin with a letter (a - z, A - B) or underscore (_) Other characters can be letters, numbers or _ Case Sensitive Can be any (reasonable) length There are some reserved words which you cannot use as a variable name because Python uses them for other things.","title":"Python Variable Name Rules"},{"location":"syntax/#good-variable-name","text":"Choose meaningful name instead of short name. roll_no is better than rn. Maintain the length of a variable name. Roll_no_of_a-student is too long? Be consistent; roll_no or RollNo Begin a variable name with an underscore(_) character for a special case. Since python in not static typed language you do not need to define the type of variables.","title":"Good Variable Name"},{"location":"syntax/#loops","text":"","title":"Loops"},{"location":"syntax/#for","text":"i=0 for i < 10: print(i) i++","title":"For"},{"location":"syntax/#while","text":"i=0 while i < 10: print(i) i++","title":"While"},{"location":"syntax/#loop-through-objects","text":"a = [1,2,3,4,5,6,7] for i in a: print(i) a=[{\"name\":\"qw\"},{\"name\":\"qwe\"}] for i in a: print(a[\"name\"])","title":"Loop through objects"},{"location":"syntax/#functions","text":"def function_add(var1, var2, var3): do_some_work return var1+var2+var3","title":"Functions"},{"location":"syntax/#default-arguements-in-functions","text":"def function_default_arg(var1, var2, var3=10): return var1+var2+var3 Here if no value is specified for var3 it will be 10 by default so you can call it like below. It also shows us a form of polymorphism which we will see later in this tutorial.","title":"Default arguements in functions"},{"location":"tooling/","text":"To begin with python tooling, lets first see what these tools are used for. Starting a project To start any project it is always recommended to create the project in its own environment. This means that anything that is installed for python at global level will not affect this env anf vice versa. How to start development? VirutalENV: Install virtualenv sudo apt-get install virtualenv After installation activate it. virtualenv env_name -m python3 This will create an env for python 3 and you can start working inside it. Keep in mind that you have to activate the env before running your code to make it work. Activate env: sourve env_name/bin/activate Now you can install any packages that you want to use in your python program. Deactivate env: deactivate Pep8 formatting. Pep8 is the formatting style that defines how you should format your python program. How you should name your variables and more such conventions. Pep8 is highly recommende for anyone who want to work with opensource community. Dependency Management For dependency management in python we use pip. It is used for installing packages. You can have a file naming requirements.txt which will have all the packages that you need to install along with the version that you want to install. How to install python package: pip install package_name How to install using requirements.txt pip install -r requirements.txt Editor? Pycharm is very good for python but if you are power user of sublime that will be awesome.","title":"Basic Tooling for Python"},{"location":"tooling/#starting-a-project","text":"To start any project it is always recommended to create the project in its own environment. This means that anything that is installed for python at global level will not affect this env anf vice versa.","title":"Starting a project"},{"location":"tooling/#how-to-start-development","text":"","title":"How to start development?"},{"location":"tooling/#virutalenv","text":"Install virtualenv sudo apt-get install virtualenv After installation activate it. virtualenv env_name -m python3 This will create an env for python 3 and you can start working inside it. Keep in mind that you have to activate the env before running your code to make it work. Activate env: sourve env_name/bin/activate Now you can install any packages that you want to use in your python program. Deactivate env: deactivate","title":"VirutalENV:"},{"location":"tooling/#pep8-formatting","text":"Pep8 is the formatting style that defines how you should format your python program. How you should name your variables and more such conventions. Pep8 is highly recommende for anyone who want to work with opensource community.","title":"Pep8 formatting."},{"location":"tooling/#dependency-management","text":"For dependency management in python we use pip. It is used for installing packages. You can have a file naming requirements.txt which will have all the packages that you need to install along with the version that you want to install.","title":"Dependency Management"},{"location":"tooling/#how-to-install-python-package","text":"pip install package_name","title":"How to install python package:"},{"location":"tooling/#how-to-install-using-requirementstxt","text":"pip install -r requirements.txt","title":"How to install using requirements.txt"},{"location":"tooling/#editor","text":"Pycharm is very good for python but if you are power user of sublime that will be awesome.","title":"Editor?"}]}