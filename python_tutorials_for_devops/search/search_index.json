{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Python Training for devops Python is a well known programming language which is used for scripting, data science, software and system development. It is one of the most used language of these days. This training course is for devops people who want to use python in their projects and later use it in a full fledge development. In this course we will talk about OOPS, CLI applications in python, frameworks in python, GIL, memory management, basic tooling around python, etc.","title":"Home"},{"location":"#welcome-to-python-training-for-devops","text":"Python is a well known programming language which is used for scripting, data science, software and system development. It is one of the most used language of these days. This training course is for devops people who want to use python in their projects and later use it in a full fledge development. In this course we will talk about OOPS, CLI applications in python, frameworks in python, GIL, memory management, basic tooling around python, etc.","title":"Welcome to Python Training for devops"},{"location":"best_practices/","text":"Best practices for programming and python Add readability to your code as much as possible. Function name should tell what this function does. Function should be visible in one screen. You should not scroll to view the whole function. Try to write pure funtions instead of impure functions. Read here about pure and impure functions One function should do one thing and that thing properly. Logging is very important. You should chose level of logging very wisely. Lot of logging will make your application slow. Less logging you may miss out required info for debugging. Failures are normal. Fail as early as possible and as loud as possible. Metrics provides you with a way to keep track what your code is working with respect to how it was working earlier. Try to structure your code in such a way that if you want to add something new you can do it in minimum effort. Documentation is very important. Try to document project you are about to build in advance this will make your thought clear about what you are going to make and how you will achieve it. Comment wherever is necessary. You comments will help the person who will take over code to understand it easily. You program should be config driven. Don't hardcode anything in your code. Test cases are very important. You will have confidence in your code and less bug will go to production. Edge cases are important to consider. There are people who actually do test driven development. This means they write the test case first for what they want to achieve and then they write the code for it. Always think that your software may need to interact with other software in future so write it in a way that others can interact with it.","title":"Best Practices for programming and python"},{"location":"best_practices/#best-practices-for-programming-and-python","text":"Add readability to your code as much as possible. Function name should tell what this function does. Function should be visible in one screen. You should not scroll to view the whole function. Try to write pure funtions instead of impure functions. Read here about pure and impure functions One function should do one thing and that thing properly. Logging is very important. You should chose level of logging very wisely. Lot of logging will make your application slow. Less logging you may miss out required info for debugging. Failures are normal. Fail as early as possible and as loud as possible. Metrics provides you with a way to keep track what your code is working with respect to how it was working earlier. Try to structure your code in such a way that if you want to add something new you can do it in minimum effort. Documentation is very important. Try to document project you are about to build in advance this will make your thought clear about what you are going to make and how you will achieve it. Comment wherever is necessary. You comments will help the person who will take over code to understand it easily. You program should be config driven. Don't hardcode anything in your code. Test cases are very important. You will have confidence in your code and less bug will go to production. Edge cases are important to consider. There are people who actually do test driven development. This means they write the test case first for what they want to achieve and then they write the code for it. Always think that your software may need to interact with other software in future so write it in a way that others can interact with it.","title":"Best practices for programming and python"},{"location":"cliapp/","text":"Introduction In this part we will be creating a cli application using a well known framework called Click. What you need to start this? Basic knowledge of python syntax loops, how to use packages and how to run python program. Knowledge of cli app will be a good addition. Click package Click is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It\u2019s the \u201cCommand Line Interface Creation Kit\u201d. It\u2019s highly configurable but comes with sensible defaults out of the box. Click adds functionality like help by default which is very useful in case of cli apps. Functionality like below (venv) $chowmean@chowmean-MACH-WX9:$ python hello_click.py help Usage: hello_click.py [OPTIONS] Try \"hello_click.py --help\" for help. Error: Got unexpected extra argument (help) (venv) $chowmean@chowmean-MACH-WX9:$ python hello_click.py --help Usage: hello_click.py [OPTIONS] Simple program that greets NAME for a total of COUNT times. Options: --help Show this message and exit. (venv) $chowmean@chowmean-MACH-WX9:$ Lets code Create a directory for your project. Then create a requirements.txt file in your directory. After that initialize an empty env for you python project and then run pip install to install the required packages. Here package will be click so put click in your requirements file. All of this is below mkdir project_name cd project_name & & touch requirements.txt virtualenv venv source venv/bin/activate echo \"click\" >> requirements.txt pip install -r requirements.txt Our project directory is ready create a file with any name and start writing the code below. Here we will be creating a very basic cli app which says hello. import click @click.command() def hello(): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" click.echo('Hello') if __name__ == '__main__': hello() Save the above snippet in file called hello.py Run this using python hello.py and you will see hello as output. Arguments and options Lets first distinguish between these two. Options are the values that you can provide to your program through CLI. Arguments work similarly to options but are positional. They also only support a subset of the features of options due to their syntactical nature. Arguments cannot do anything more than options so we will have a look at options in detail Options For taking options click provide a very easy options. Have a look at code below import click @click.command() @click.option('--name', prompt='Your name', help='The person to greet.') def hello(name): for x in range(10): click.echo('Hello %s!' % name) if __name__ == '__main__': hello() Here you can take your name as CLI argument and then this program will print hello your_name. Run this command to run it. python hello.py --name=conan Now you can divide options in two type required and optional ones. For that you only have to pass required=True and that option will be mandatory import click @click.command() @click.option('--name', prompt='Your name', help='The person to greet.', required=True) @click.option('--age', prompt='Your age', help=\"The person's age.\", default=35) def hello(name, age): for x in range(1): click.echo('%s is %s years old!!!' % (name,age)) if __name__ == '__main__': hello() In above code now name is a mandatory option. Prompts Prompts are a way to take user in input at the run time. These are useful when you want to enter some password and don't want it to be recorded in history command. There are two types of prompts here. Input prompts. Input prompts are used for taking inputs from users. Look at the example below value = click.prompt('Please enter your nanme', type=string) Confirmation prompts. Confirmation prompts are for confirming if you want to continue. import click @click.command() def hello(): if click.confirm('Do you want to continue?'): click.echo('user entered yes') else: click.echo('user entered No') if __name__ == '__main__': hello() Examples: this example explains about hiding the prompted value(useful in case of passwords) import click @click.command() @click.option('--password', prompt=True, hide_input=True, confirmation_prompt=True) def encrypt(password): click.echo('Encrypting password to %s' % password.encode('rot13')) if name == ' main ': encrypt() You can give option abort=True . If you want to abort on not confirming. import click @click.command() def hello(): if click.confirm('Do you want to continue?', default=True, abort=True): click.echo('user entered yes') else: click.echo('user entered No') print \"!!!Yahhoo... user allowed me to get execute by entering Yes\" if name == ' main ': hello() Click application to pull repos Here we will build a very small application to get all the public github repos of any users. Lets first plan how we will do this. So there will be only two steps. One where we ask for the username of the user to search repos for and next is getting the repo and printing it. For first part we will get username like below import click @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') def get_projects(username): return username if __name__ == '__main__': get_projects() Here we got the input from user to get the username. Now we have to get the details of its repository. For that we need to make an api call to open githib apis. For making http calls in python we use a very famous library called requests. Look at the code below to understand how requests library works. import requests a = requests.get(\"www.google.com\") print(a.content) As simple as this. It supports all the options that are there in http calls like headers, methods etc. We will use this library to make a call to github api. Look at the code below import click import requests @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') def get_projects(username): a = requests.get(\"https://api.github.com/users/\"+username+\"/repos\") print(a.content) if __name__ == '__main__': get_projects() You got the list of repository but they have lot more data and they need to be in understood by program as object. Right now they are in json format. For handling json we have a library called json in python Lets see that.. import click import requests import json @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') def get_projects(username): a = requests.get(\"https://api.github.com/users/\"+username+\"/repos\") data = json.loads(a.content) for item in data: print item['name'] if __name__ == '__main__': get_projects() This will print the names of all the repos","title":"Creating a CLI application"},{"location":"cliapp/#introduction","text":"In this part we will be creating a cli application using a well known framework called Click.","title":"Introduction"},{"location":"cliapp/#what-you-need-to-start-this","text":"Basic knowledge of python syntax loops, how to use packages and how to run python program. Knowledge of cli app will be a good addition.","title":"What you need to start this?"},{"location":"cliapp/#click-package","text":"Click is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It\u2019s the \u201cCommand Line Interface Creation Kit\u201d. It\u2019s highly configurable but comes with sensible defaults out of the box. Click adds functionality like help by default which is very useful in case of cli apps. Functionality like below (venv) $chowmean@chowmean-MACH-WX9:$ python hello_click.py help Usage: hello_click.py [OPTIONS] Try \"hello_click.py --help\" for help. Error: Got unexpected extra argument (help) (venv) $chowmean@chowmean-MACH-WX9:$ python hello_click.py --help Usage: hello_click.py [OPTIONS] Simple program that greets NAME for a total of COUNT times. Options: --help Show this message and exit. (venv) $chowmean@chowmean-MACH-WX9:$","title":"Click package"},{"location":"cliapp/#lets-code","text":"Create a directory for your project. Then create a requirements.txt file in your directory. After that initialize an empty env for you python project and then run pip install to install the required packages. Here package will be click so put click in your requirements file. All of this is below mkdir project_name cd project_name & & touch requirements.txt virtualenv venv source venv/bin/activate echo \"click\" >> requirements.txt pip install -r requirements.txt Our project directory is ready create a file with any name and start writing the code below. Here we will be creating a very basic cli app which says hello. import click @click.command() def hello(): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" click.echo('Hello') if __name__ == '__main__': hello() Save the above snippet in file called hello.py Run this using python hello.py and you will see hello as output.","title":"Lets code"},{"location":"cliapp/#arguments-and-options","text":"Lets first distinguish between these two. Options are the values that you can provide to your program through CLI. Arguments work similarly to options but are positional. They also only support a subset of the features of options due to their syntactical nature. Arguments cannot do anything more than options so we will have a look at options in detail","title":"Arguments and options"},{"location":"cliapp/#options","text":"For taking options click provide a very easy options. Have a look at code below import click @click.command() @click.option('--name', prompt='Your name', help='The person to greet.') def hello(name): for x in range(10): click.echo('Hello %s!' % name) if __name__ == '__main__': hello() Here you can take your name as CLI argument and then this program will print hello your_name. Run this command to run it. python hello.py --name=conan Now you can divide options in two type required and optional ones. For that you only have to pass required=True and that option will be mandatory import click @click.command() @click.option('--name', prompt='Your name', help='The person to greet.', required=True) @click.option('--age', prompt='Your age', help=\"The person's age.\", default=35) def hello(name, age): for x in range(1): click.echo('%s is %s years old!!!' % (name,age)) if __name__ == '__main__': hello() In above code now name is a mandatory option.","title":"Options"},{"location":"cliapp/#prompts","text":"Prompts are a way to take user in input at the run time. These are useful when you want to enter some password and don't want it to be recorded in history command. There are two types of prompts here.","title":"Prompts"},{"location":"cliapp/#input-prompts","text":"Input prompts are used for taking inputs from users. Look at the example below value = click.prompt('Please enter your nanme', type=string)","title":"Input prompts."},{"location":"cliapp/#confirmation-prompts","text":"Confirmation prompts are for confirming if you want to continue. import click @click.command() def hello(): if click.confirm('Do you want to continue?'): click.echo('user entered yes') else: click.echo('user entered No') if __name__ == '__main__': hello()","title":"Confirmation prompts."},{"location":"cliapp/#examples","text":"this example explains about hiding the prompted value(useful in case of passwords) import click @click.command() @click.option('--password', prompt=True, hide_input=True, confirmation_prompt=True) def encrypt(password): click.echo('Encrypting password to %s' % password.encode('rot13')) if name == ' main ': encrypt() You can give option abort=True . If you want to abort on not confirming. import click @click.command() def hello(): if click.confirm('Do you want to continue?', default=True, abort=True): click.echo('user entered yes') else: click.echo('user entered No') print \"!!!Yahhoo... user allowed me to get execute by entering Yes\" if name == ' main ': hello()","title":"Examples:"},{"location":"cliapp/#click-application-to-pull-repos","text":"Here we will build a very small application to get all the public github repos of any users. Lets first plan how we will do this. So there will be only two steps. One where we ask for the username of the user to search repos for and next is getting the repo and printing it. For first part we will get username like below import click @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') def get_projects(username): return username if __name__ == '__main__': get_projects() Here we got the input from user to get the username. Now we have to get the details of its repository. For that we need to make an api call to open githib apis. For making http calls in python we use a very famous library called requests. Look at the code below to understand how requests library works. import requests a = requests.get(\"www.google.com\") print(a.content) As simple as this. It supports all the options that are there in http calls like headers, methods etc. We will use this library to make a call to github api. Look at the code below import click import requests @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') def get_projects(username): a = requests.get(\"https://api.github.com/users/\"+username+\"/repos\") print(a.content) if __name__ == '__main__': get_projects() You got the list of repository but they have lot more data and they need to be in understood by program as object. Right now they are in json format. For handling json we have a library called json in python Lets see that.. import click import requests import json @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') def get_projects(username): a = requests.get(\"https://api.github.com/users/\"+username+\"/repos\") data = json.loads(a.content) for item in data: print item['name'] if __name__ == '__main__': get_projects() This will print the names of all the repos","title":"Click application to pull repos"},{"location":"decorators/","text":"Decorators First-Class Objects First class objects in a language are handled uniformly throughout. These are the some properties of first class objects To be named by variables. To be passed as arguments to procedures. To be returned as values of procedures. To be incorporated into data structures In Python, functions are first-class objects. This means that functions can be passed around and used as arguments, just like any other object (string, int, float, list, and so on). Consider the following three functions: Example 1 def say_hello(name): return \"Hello %s\"% name def be_awesome(name): return \"Yo %s\"% name def greet_bob(greeter_func): return greeter_func(\"Bob\") Here, say_hello() and be_awesome() are regular functions that expect a name given as a string. The greet_bob() function however, expects a function as its argument. We can, for instance, pass it the say_hello() or the be_awesome() function:. We can execute in python shell >>> greet_bob(say_hello) 'Hello Bob' >>> greet_bob(be_awesome) 'Yo Bob' Inner Functions: It\u2019s possible to define functions inside other functions. Such functions are called inner functions. Here\u2019s an example of a function with two inner functions: def parent(): print(\"Printing from the parent() function\") def first_child(): print(\"Printing from the first_child() function\") def second_child(): print(\"Printing from the second_child() function\") second_child() first_child() what happens when you call parent function? >>> parent() Printing from the parent() function Printing from the second_child() function Printing from the first_child() function Note that the order in which the inner functions are defined does not matter. Like with any other functions, the printing only happens when the inner functions are executed. Furthermore, the inner functions are not defined until the parent function is called. They are locally scoped to parent(): they only exist inside the parent() function as local variables. Try calling first_child(). You should get an error: >>>first_child() Traceback (most recent call last): File \" \", line 1, in NameError: name 'first_child' is not defined Whenever you call parent(), the inner functions first_child() and second_child() are also called. But because of their local scope, they aren\u2019t available outside of the parent() function. Returning Functions From Functions: Python also allows you to use functions as return values. The following example returns one of the inner functions from the outer parent() function: def parent(num): def first_child(): return \"Hi, I am Emma\" def second_child(): return \"Call me Liam\" if num == 1: return first_child else: return second_child Note that you are returning first_child without the parentheses. Recall that this means that you are returning a reference to the function first_child. In contrast first_child() with parentheses refers to the result of evaluating the function. This can be seen in the following example: >>> first = parent(1) >>> second = parent(2) >>> first .first_child at 0x7f599f1e2e18>' >>> second .second_child at 0x7f599dad5268> You can now use first and second as if they are regular functions, even though the functions they point to can\u2019t be accessed directly: >>> first() 'Hi, I am Emma' >>> second() 'Call me Liam' Simple Decorators: Now that you\u2019ve seen that functions are just like any other object in Python, you\u2019re ready to move on and see the magical beast that is the Python decorator. Let\u2019s start with an example Example: def my_decorator(func): def wrapper(): print(\"Something is happening before the function is called.\") func() print(\"Something is happening after the function is called.\") return wrapper def say_whee(): print(\"Whee!\") say_whee = my_decorator(say_whee) Can you guess what happens when you call say_whee()? Try it: >>> say_whee() Something is happening before the function is called. Whee! Something is happening after the function is called. To understand what\u2019s going on here, look back at the previous examples. We are literally just applying everything you have learned so far. The so-called decoration happens at the following line: say_whee = my_decorator(say_whee) In effect, the name say_whee now points to the wrapper() inner function. Remember that you return wrapper as a function when you call my_decorator(say_whee): >>> say_whee .wrapper at 0x7f3c5dfd42f0> However, wrapper() has a reference to the original say_whee() as func, and calls that function between the two calls to print(). Put simply: decorators wrap a function, modifying its behavior. Example: from datetime import datetime def not_during_the_night(func): def wrapper(): if 7 = datetime.now().hour 22: func() else: pass # Hush, the neighbors are asleep return wrapper def say_whee(): print(\"Whee!\") say_whee = not_during_the_night(say_whee) If you try to call say_whee() after bedtime, nothing will happen: >>> say_whee() Syntactic Sugar! The way you decorated say_whee() above is a little heavy. First of all, you end up typing the name say_whee three times. Python allows you to use decorators in a simpler way with the @ symbol, sometimes called the \u201cpie\u201d syntax. The following example does the exact same thing as the first decorator example: Example: def my_decorator(func): def wrapper(): print(\"Something is happening before the function is called.\") func() print(\"Something is happening after the function is called.\") return wrapper @my_decorator def say_whee(): print(\"Whee!\") Reusing Decorators: Recall that a decorator is just a regular Python function. All the usual tools for easy reusability are available. Let\u2019s move the decorator to its own module that can be used in many other functions. def do_twice(func): def wrapper_do_twice(): func() func() return wrapper_do_twice @do_twice def say_whee(): print(\"Whee!\") Decorating Functions With Arguments: Say that you have a function that accepts some arguments. Can you still decorate it? Let\u2019s try: Example: def do_twice(func): def wrapper_do_twice(): func() func() return wrapper_do_twice @do_twice def greet(name): print \" hello %s\"%name def say_whee(): print \"Whee!\" Unfortunately, running this code raises an error: >>> greet(\"World\") Traceback (most recent call last): File \" \", line 1, in TypeError: wrapper_do_twice() takes 0 positional arguments but 1 was given The problem is that the inner function wrapper_do_twice() does not take any arguments, but name=\"World\" was passed to it. You could fix this by letting wrapper_do_twice() accept one argument, but then it would not work for the say_whee() function you created earlier. The solution is to use args and *kwargs in the inner wrapper function. Then it will accept an arbitrary number of positional and keyword arguments. Rewrite decorators.py as follows: def do_twice(func): def wrapper_do_twice(*args, **kwargs): func(*args, **kwargs) func(*args, **kwargs) return wrapper_do_twice @do_twice def greet(name): print \" hello %s\"%name def say_whee(): print \"Whee!\" Now call functions >>> say_whee() Whee! Whee! >>> greet(\"World\") Hello World Hello World Returning Values From Decorated Functions: What happens to the return value of decorated functions? Well, that\u2019s up to the decorator to decide. Let\u2019s say you decorate a simple function as follows: def do_twice(func): def wrapper_do_twice( args, kwargs): func(*args, kwargs) func( args, **kwargs) return wrapper_do_twice @do_twice def return_greeting(name): print(\"Creating greeting\") return \"Hi %s\"%name Call function >>> hi_adam = return_greeting(\"Adam\") Creating greeting Creating greeting >>> print(hi_adam) None Oops, your decorator ate the return value from the function. modify your wrapper to return something def do_twice(func): def wrapper_do_twice(*args, **kwargs): func(*args, **kwargs) return func(*args, **kwargs) return wrapper_do_twice Real world use cases: Timing functions Registering functions checking for authentication Examples: from flask import Flask, g, request, redirect, url_for import functools app = Flask( name ) def login_required(func): \"\"\"Make sure user is logged in before proceeding\"\"\" @functools.wraps(func) def wrapper_login_required(*args, kwargs): if g.user is None: return redirect(url_for(\"login\", next=request.url)) return func(*args, kwargs) return wrapper_login_required @app.route(\"/secret\") @login_required def secret(): ...","title":"Decorators"},{"location":"decorators/#decorators","text":"","title":"Decorators"},{"location":"decorators/#first-class-objects","text":"First class objects in a language are handled uniformly throughout. These are the some properties of first class objects To be named by variables. To be passed as arguments to procedures. To be returned as values of procedures. To be incorporated into data structures In Python, functions are first-class objects. This means that functions can be passed around and used as arguments, just like any other object (string, int, float, list, and so on). Consider the following three functions:","title":"First-Class Objects"},{"location":"decorators/#example-1","text":"def say_hello(name): return \"Hello %s\"% name def be_awesome(name): return \"Yo %s\"% name def greet_bob(greeter_func): return greeter_func(\"Bob\") Here, say_hello() and be_awesome() are regular functions that expect a name given as a string. The greet_bob() function however, expects a function as its argument. We can, for instance, pass it the say_hello() or the be_awesome() function:. We can execute in python shell >>> greet_bob(say_hello) 'Hello Bob' >>> greet_bob(be_awesome) 'Yo Bob'","title":"Example 1"},{"location":"decorators/#inner-functions","text":"It\u2019s possible to define functions inside other functions. Such functions are called inner functions. Here\u2019s an example of a function with two inner functions: def parent(): print(\"Printing from the parent() function\") def first_child(): print(\"Printing from the first_child() function\") def second_child(): print(\"Printing from the second_child() function\") second_child() first_child() what happens when you call parent function? >>> parent() Printing from the parent() function Printing from the second_child() function Printing from the first_child() function Note that the order in which the inner functions are defined does not matter. Like with any other functions, the printing only happens when the inner functions are executed. Furthermore, the inner functions are not defined until the parent function is called. They are locally scoped to parent(): they only exist inside the parent() function as local variables. Try calling first_child(). You should get an error: >>>first_child() Traceback (most recent call last): File \" \", line 1, in NameError: name 'first_child' is not defined Whenever you call parent(), the inner functions first_child() and second_child() are also called. But because of their local scope, they aren\u2019t available outside of the parent() function.","title":"Inner Functions:"},{"location":"decorators/#returning-functions-from-functions","text":"Python also allows you to use functions as return values. The following example returns one of the inner functions from the outer parent() function: def parent(num): def first_child(): return \"Hi, I am Emma\" def second_child(): return \"Call me Liam\" if num == 1: return first_child else: return second_child Note that you are returning first_child without the parentheses. Recall that this means that you are returning a reference to the function first_child. In contrast first_child() with parentheses refers to the result of evaluating the function. This can be seen in the following example: >>> first = parent(1) >>> second = parent(2) >>> first .first_child at 0x7f599f1e2e18>' >>> second .second_child at 0x7f599dad5268> You can now use first and second as if they are regular functions, even though the functions they point to can\u2019t be accessed directly: >>> first() 'Hi, I am Emma' >>> second() 'Call me Liam'","title":"Returning Functions From Functions:"},{"location":"decorators/#simple-decorators","text":"Now that you\u2019ve seen that functions are just like any other object in Python, you\u2019re ready to move on and see the magical beast that is the Python decorator. Let\u2019s start with an example Example: def my_decorator(func): def wrapper(): print(\"Something is happening before the function is called.\") func() print(\"Something is happening after the function is called.\") return wrapper def say_whee(): print(\"Whee!\") say_whee = my_decorator(say_whee) Can you guess what happens when you call say_whee()? Try it: >>> say_whee() Something is happening before the function is called. Whee! Something is happening after the function is called. To understand what\u2019s going on here, look back at the previous examples. We are literally just applying everything you have learned so far. The so-called decoration happens at the following line: say_whee = my_decorator(say_whee) In effect, the name say_whee now points to the wrapper() inner function. Remember that you return wrapper as a function when you call my_decorator(say_whee): >>> say_whee .wrapper at 0x7f3c5dfd42f0> However, wrapper() has a reference to the original say_whee() as func, and calls that function between the two calls to print().","title":"Simple Decorators:"},{"location":"decorators/#put-simply-decorators-wrap-a-function-modifying-its-behavior","text":"","title":"Put simply: decorators wrap a function, modifying its behavior."},{"location":"decorators/#example","text":"from datetime import datetime def not_during_the_night(func): def wrapper(): if 7 = datetime.now().hour 22: func() else: pass # Hush, the neighbors are asleep return wrapper def say_whee(): print(\"Whee!\") say_whee = not_during_the_night(say_whee) If you try to call say_whee() after bedtime, nothing will happen: >>> say_whee()","title":"Example:"},{"location":"decorators/#syntactic-sugar","text":"The way you decorated say_whee() above is a little heavy. First of all, you end up typing the name say_whee three times. Python allows you to use decorators in a simpler way with the @ symbol, sometimes called the \u201cpie\u201d syntax. The following example does the exact same thing as the first decorator example:","title":"Syntactic Sugar!"},{"location":"decorators/#example_1","text":"def my_decorator(func): def wrapper(): print(\"Something is happening before the function is called.\") func() print(\"Something is happening after the function is called.\") return wrapper @my_decorator def say_whee(): print(\"Whee!\")","title":"Example:"},{"location":"decorators/#reusing-decorators","text":"Recall that a decorator is just a regular Python function. All the usual tools for easy reusability are available. Let\u2019s move the decorator to its own module that can be used in many other functions. def do_twice(func): def wrapper_do_twice(): func() func() return wrapper_do_twice @do_twice def say_whee(): print(\"Whee!\")","title":"Reusing Decorators:"},{"location":"decorators/#decorating-functions-with-arguments","text":"Say that you have a function that accepts some arguments. Can you still decorate it? Let\u2019s try: Example: def do_twice(func): def wrapper_do_twice(): func() func() return wrapper_do_twice @do_twice def greet(name): print \" hello %s\"%name def say_whee(): print \"Whee!\" Unfortunately, running this code raises an error: >>> greet(\"World\") Traceback (most recent call last): File \" \", line 1, in TypeError: wrapper_do_twice() takes 0 positional arguments but 1 was given The problem is that the inner function wrapper_do_twice() does not take any arguments, but name=\"World\" was passed to it. You could fix this by letting wrapper_do_twice() accept one argument, but then it would not work for the say_whee() function you created earlier. The solution is to use args and *kwargs in the inner wrapper function. Then it will accept an arbitrary number of positional and keyword arguments. Rewrite decorators.py as follows: def do_twice(func): def wrapper_do_twice(*args, **kwargs): func(*args, **kwargs) func(*args, **kwargs) return wrapper_do_twice @do_twice def greet(name): print \" hello %s\"%name def say_whee(): print \"Whee!\" Now call functions >>> say_whee() Whee! Whee! >>> greet(\"World\") Hello World Hello World","title":"Decorating Functions With Arguments:"},{"location":"decorators/#returning-values-from-decorated-functions","text":"What happens to the return value of decorated functions? Well, that\u2019s up to the decorator to decide. Let\u2019s say you decorate a simple function as follows: def do_twice(func): def wrapper_do_twice( args, kwargs): func(*args, kwargs) func( args, **kwargs) return wrapper_do_twice @do_twice def return_greeting(name): print(\"Creating greeting\") return \"Hi %s\"%name Call function >>> hi_adam = return_greeting(\"Adam\") Creating greeting Creating greeting >>> print(hi_adam) None Oops, your decorator ate the return value from the function. modify your wrapper to return something def do_twice(func): def wrapper_do_twice(*args, **kwargs): func(*args, **kwargs) return func(*args, **kwargs) return wrapper_do_twice","title":"Returning Values From Decorated Functions:"},{"location":"decorators/#real-world-use-cases","text":"Timing functions Registering functions checking for authentication","title":"Real world use cases:"},{"location":"decorators/#examples","text":"from flask import Flask, g, request, redirect, url_for import functools app = Flask( name ) def login_required(func): \"\"\"Make sure user is logged in before proceeding\"\"\" @functools.wraps(func) def wrapper_login_required(*args, kwargs): if g.user is None: return redirect(url_for(\"login\", next=request.url)) return func(*args, kwargs) return wrapper_login_required @app.route(\"/secret\") @login_required def secret(): ...","title":"Examples:"},{"location":"flask/","text":"Flask A Minimal Application A minimal Flask application looks something like this: from flask import Flask app = Flask(__name__) @app.route('/') def get_user_data(user): user_data = db.get(user) return user_Data So what did that code do? First we imported the Flask class. An instance of this class will be our WSGI application. Next we create an instance of this class. The first argument is the name of the application\u2019s module or package. If you are using a single module (as in this example), you should use name because depending on if it\u2019s started as application or imported as module the name will be different (' main ' versus the actual import name). This is needed so that Flask knows where to look for templates, static files, and so on. For more information have a look at the Flask documentation. We then use the route() decorator to tell Flask what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function, and returns the message we want to display in the user\u2019s browser. Just save it as hello.py or something similar. Make sure to not call your application flask.py because this would conflict with Flask itself. To run the application you can either use the flask command or python\u2019s -m switch with Flask. Before you can do that you need to tell your terminal the application to work with by exporting the FLASK_APP environment variable: $ export FLASK_APP=hello.py $ flask run * Running on http://127.0.0.1:5000/ Alternatively you can use python -m flask: $ export FLASK_APP=hello.py $ python -m flask run * Running on http://127.0.0.1:5000/ This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production Externally Visible Server: If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer. If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding --host=0.0.0.0 to the command line: flask run --host=0.0.0.0 This tells your operating system to listen on all public IPs. what happens when type flask run? Debug Mode: server will reload itself on code changes provide you with a helpful debugger export FLASK_ENV=development flask run Variable Rules: You can add variable sections to a URL by marking sections with . Your function then receives the as a keyword argument. Optionally, you can use a converter to specify the type of the argument like . from flask import Flask, render_template, escape app = Flask(__name__) @app.route('/user/ username ') def show_user_profile(username): # show the user profile for that user return 'User %s' % escape(username) @app.route('/post/ int:post_id ') def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id @app.route('/path/ path:subpath ') def show_subpath(subpath): # show the subpath after /path/ return 'Subpath %s' % subpath types of converters: 1. string 2. int 3. float 4. path 5. uuid Unique URLs / Redirection Behavior The following two rules differ in their use of a trailing slash. from flask import Flask app = Flask(__name__) @app.route('/projects/') def projects(): return 'The project page' @app.route('/about') def about(): return 'The about page' Rendering Templates Example1: Flask configures the Jinja2 template engine for you automatically we can use render_template method to render htmls. from flask import Flask, render_template app = Flask(__name__) @app.route('/hello/') @app.route('/hello/ name ') def hello(name=None): return render_template('hello.html', name=name) hello.html !doctype html title Hello from Flask /title {% if name %} Hello {{name}} {% else %} Hello, World! {% endif %} Example2: Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to GET requests. You can use the methods argument of the route() decorator to handle different HTTP methods. from flask import Flask, render_template app = Flask(__name__) @app.route('/login', methods=['GET', 'POST']) def login(): error = None if request.method == 'POST': if request.form['username'] != 'admin' or request.form['password'] != 'admin': error = 'Invalid Credentials. Please try again.' else: return redirect(url_for('home')) return render_template('login.html', error=error) @app.route('/home') def home(): render_template('home.html') login.html html head title Flask Intro - login page /title meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" link href=\"static/bootstrap.min.css\" rel=\"stylesheet\" media=\"screen\" /head body div class=\"container\" h1 Please login /h1 br form action=\"\" method=\"post\" input type=\"text\" placeholder=\"Username\" name=\"username\" value=\"{{ request.form.username }}\" input type=\"password\" placeholder=\"Password\" name=\"password\" value=\"{{ request.form.password }}\" input class=\"btn btn-default\" type=\"submit\" value=\"Login\" /form {% if error %} p class=\"error\" strong Error: /strong {{ error }} {% endif %} /div /body /html home.html html head title Home page /title meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" link href=\"static/bootstrap.min.css\" rel=\"stylesheet\" media=\"screen\" /head body div class=\"container\" h1 This is home /h1 /div /body /html Redirects: from flask import abort, redirect, url_for app = Flask(__name__) @app.route('/') def index(): return redirect(url_for('login')) @app.route('/login') def login(): return 'Hey.. You just landed on log in page' Errors: from flask import Flask, redirect, redirect app = Flask(__name__) @app.route('/') def index(): return redirect(redirect('login')) @app.route('/login') def login(): return 'Hey.. You just landed on log in page' @app.errorhandler(404) def page_not_found(error): return 'Hey.. you landed on mising page.. br ul li / /li li /login /li /ul ' APIs with JSON: from flask import Flask, redirect, redirect app = Flask(__name__) @app.route(\"/data\") def data(): user = get_current_user() return { \"username\": user[\"name\"], \"age\": user['age'] } def get_current_user(): return {'name':'ram', 'age':20} Cookies setting cookies: from flask import Flas, make_response app = Flask(__name__) @app.route('/set_cookie') def set_cookie(): resp = make_response('hello world') username = request.args.get('username') resp.set_cookie('username', username) return resp reading cookies from flask import Flask, request app = Flask(__name__) @app.route('/get_cookie') def read_cookie(): username = request.cookies.get('username') return 'hello %'%username Sessions: from flask import Flask, session, redirect, url_for, escape, request app = Flask(__name__) # Set the secret key to some random bytes. Keep this really secret! app.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/' @app.route('/') def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in' @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': session['username'] = request.form['username'] return redirect(url_for('index')) return ''' form method=\"post\" p input type=text name=username p input type=submit value=Login /form ''' @app.route('/logout') def logout(): # remove the username from the session if it's there session.pop('username', None) return redirect(url_for('index'))","title":"Flask"},{"location":"flask/#flask","text":"","title":"Flask"},{"location":"flask/#a-minimal-application","text":"A minimal Flask application looks something like this: from flask import Flask app = Flask(__name__) @app.route('/') def get_user_data(user): user_data = db.get(user) return user_Data","title":"A Minimal Application"},{"location":"flask/#so-what-did-that-code-do","text":"First we imported the Flask class. An instance of this class will be our WSGI application. Next we create an instance of this class. The first argument is the name of the application\u2019s module or package. If you are using a single module (as in this example), you should use name because depending on if it\u2019s started as application or imported as module the name will be different (' main ' versus the actual import name). This is needed so that Flask knows where to look for templates, static files, and so on. For more information have a look at the Flask documentation. We then use the route() decorator to tell Flask what URL should trigger our function. The function is given a name which is also used to generate URLs for that particular function, and returns the message we want to display in the user\u2019s browser. Just save it as hello.py or something similar. Make sure to not call your application flask.py because this would conflict with Flask itself. To run the application you can either use the flask command or python\u2019s -m switch with Flask. Before you can do that you need to tell your terminal the application to work with by exporting the FLASK_APP environment variable: $ export FLASK_APP=hello.py $ flask run * Running on http://127.0.0.1:5000/ Alternatively you can use python -m flask: $ export FLASK_APP=hello.py $ python -m flask run * Running on http://127.0.0.1:5000/ This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production","title":"So what did that code do?"},{"location":"flask/#externally-visible-server","text":"If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer. If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding --host=0.0.0.0 to the command line: flask run --host=0.0.0.0 This tells your operating system to listen on all public IPs.","title":"Externally Visible Server:"},{"location":"flask/#what-happens-when-type-flask-run","text":"","title":"what happens when type flask run?"},{"location":"flask/#debug-mode","text":"server will reload itself on code changes provide you with a helpful debugger export FLASK_ENV=development flask run","title":"Debug Mode:"},{"location":"flask/#variable-rules","text":"You can add variable sections to a URL by marking sections with . Your function then receives the as a keyword argument. Optionally, you can use a converter to specify the type of the argument like . from flask import Flask, render_template, escape app = Flask(__name__) @app.route('/user/ username ') def show_user_profile(username): # show the user profile for that user return 'User %s' % escape(username) @app.route('/post/ int:post_id ') def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id @app.route('/path/ path:subpath ') def show_subpath(subpath): # show the subpath after /path/ return 'Subpath %s' % subpath types of converters: 1. string 2. int 3. float 4. path 5. uuid","title":"Variable Rules:"},{"location":"flask/#unique-urls-redirection-behavior","text":"The following two rules differ in their use of a trailing slash. from flask import Flask app = Flask(__name__) @app.route('/projects/') def projects(): return 'The project page' @app.route('/about') def about(): return 'The about page'","title":"Unique URLs / Redirection Behavior"},{"location":"flask/#rendering-templates","text":"","title":"Rendering Templates"},{"location":"flask/#example1","text":"Flask configures the Jinja2 template engine for you automatically we can use render_template method to render htmls. from flask import Flask, render_template app = Flask(__name__) @app.route('/hello/') @app.route('/hello/ name ') def hello(name=None): return render_template('hello.html', name=name) hello.html !doctype html title Hello from Flask /title {% if name %} Hello {{name}} {% else %} Hello, World! {% endif %}","title":"Example1:"},{"location":"flask/#example2","text":"Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to GET requests. You can use the methods argument of the route() decorator to handle different HTTP methods. from flask import Flask, render_template app = Flask(__name__) @app.route('/login', methods=['GET', 'POST']) def login(): error = None if request.method == 'POST': if request.form['username'] != 'admin' or request.form['password'] != 'admin': error = 'Invalid Credentials. Please try again.' else: return redirect(url_for('home')) return render_template('login.html', error=error) @app.route('/home') def home(): render_template('home.html') login.html html head title Flask Intro - login page /title meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" link href=\"static/bootstrap.min.css\" rel=\"stylesheet\" media=\"screen\" /head body div class=\"container\" h1 Please login /h1 br form action=\"\" method=\"post\" input type=\"text\" placeholder=\"Username\" name=\"username\" value=\"{{ request.form.username }}\" input type=\"password\" placeholder=\"Password\" name=\"password\" value=\"{{ request.form.password }}\" input class=\"btn btn-default\" type=\"submit\" value=\"Login\" /form {% if error %} p class=\"error\" strong Error: /strong {{ error }} {% endif %} /div /body /html home.html html head title Home page /title meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" link href=\"static/bootstrap.min.css\" rel=\"stylesheet\" media=\"screen\" /head body div class=\"container\" h1 This is home /h1 /div /body /html","title":"Example2:"},{"location":"flask/#redirects","text":"from flask import abort, redirect, url_for app = Flask(__name__) @app.route('/') def index(): return redirect(url_for('login')) @app.route('/login') def login(): return 'Hey.. You just landed on log in page'","title":"Redirects:"},{"location":"flask/#errors","text":"from flask import Flask, redirect, redirect app = Flask(__name__) @app.route('/') def index(): return redirect(redirect('login')) @app.route('/login') def login(): return 'Hey.. You just landed on log in page' @app.errorhandler(404) def page_not_found(error): return 'Hey.. you landed on mising page.. br ul li / /li li /login /li /ul '","title":"Errors:"},{"location":"flask/#apis-with-json","text":"from flask import Flask, redirect, redirect app = Flask(__name__) @app.route(\"/data\") def data(): user = get_current_user() return { \"username\": user[\"name\"], \"age\": user['age'] } def get_current_user(): return {'name':'ram', 'age':20}","title":"APIs with JSON:"},{"location":"flask/#cookies","text":"setting cookies: from flask import Flas, make_response app = Flask(__name__) @app.route('/set_cookie') def set_cookie(): resp = make_response('hello world') username = request.args.get('username') resp.set_cookie('username', username) return resp reading cookies from flask import Flask, request app = Flask(__name__) @app.route('/get_cookie') def read_cookie(): username = request.cookies.get('username') return 'hello %'%username","title":"Cookies"},{"location":"flask/#sessions","text":"from flask import Flask, session, redirect, url_for, escape, request app = Flask(__name__) # Set the secret key to some random bytes. Keep this really secret! app.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/' @app.route('/') def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in' @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': session['username'] = request.form['username'] return redirect(url_for('index')) return ''' form method=\"post\" p input type=text name=username p input type=submit value=Login /form ''' @app.route('/logout') def logout(): # remove the username from the session if it's there session.pop('username', None) return redirect(url_for('index'))","title":"Sessions:"},{"location":"flaskandorm/","text":"ORM What are orm? A simple answer is that you wrap your tables or stored procedures in classes in your programming language, so that instead of writing SQL statements to interact with your database, you use methods and properties of objects.[stackoverflow] SQL Alchemy in flask from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db' db = SQLAlchemy(app) class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(80), unique=True, nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) def __repr__(self): return ' ' % self.username admin = User(username=\"test1asd\",email=\"aasdadsdadsad\") db.session.add(admin) db.session.commit() print(User.query.all()) Lets see what is happening above. First two line from import flask and sql alchemy Next we created application and defined app.config for sql alchemy. It has to be this variable name only app.config['SQLALCHEMY_DATABASE_URI'] . Then we intialized db instance. Next we have created User class. Then we created an instance of User and added it to the session and then commited it. This is how data is saved. Next we can query it using the User.query.all() . Flask Migrations We will use flask-migrate for keeping track of migrations. It uses alembic behind the scenes for migrations. Installation pip install flask-migrate Code Have a look at the below code from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db' db = SQLAlchemy(app) migrate = Migrate(app, db) class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(80), unique=True, nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) password = db.Column(db.String(120), unique=True, nullable=True) def __repr__(self): return ' ' % self.username As you can see there are 2 new line. Importing flask_migrate and initializing migrate. Thats it you have to do for now. How to create migration. Initializing flask db init It will generate migrations folder. Generating Migration After making code changes in model. You can run the below command to generate migrtion flask db migrate Now there will be migrations generated and you can see those in migrations/versions folder. Applying migration flask db upgrade Downgrade Migration flask db downgrade version These are very basic of how you can keep track of your database migrations. You can read more about it. There are lot of complexities involve when it comes to migration with databases. So read about it properly before using it in production.","title":"Flask and ORM"},{"location":"flaskandorm/#orm","text":"","title":"ORM"},{"location":"flaskandorm/#what-are-orm","text":"A simple answer is that you wrap your tables or stored procedures in classes in your programming language, so that instead of writing SQL statements to interact with your database, you use methods and properties of objects.[stackoverflow]","title":"What are orm?"},{"location":"flaskandorm/#sql-alchemy-in-flask","text":"from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db' db = SQLAlchemy(app) class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(80), unique=True, nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) def __repr__(self): return ' ' % self.username admin = User(username=\"test1asd\",email=\"aasdadsdadsad\") db.session.add(admin) db.session.commit() print(User.query.all()) Lets see what is happening above. First two line from import flask and sql alchemy Next we created application and defined app.config for sql alchemy. It has to be this variable name only app.config['SQLALCHEMY_DATABASE_URI'] . Then we intialized db instance. Next we have created User class. Then we created an instance of User and added it to the session and then commited it. This is how data is saved. Next we can query it using the User.query.all() .","title":"SQL Alchemy in flask"},{"location":"flaskandorm/#flask-migrations","text":"We will use flask-migrate for keeping track of migrations. It uses alembic behind the scenes for migrations.","title":"Flask Migrations"},{"location":"flaskandorm/#installation","text":"pip install flask-migrate","title":"Installation"},{"location":"flaskandorm/#code","text":"Have a look at the below code from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db' db = SQLAlchemy(app) migrate = Migrate(app, db) class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(80), unique=True, nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) password = db.Column(db.String(120), unique=True, nullable=True) def __repr__(self): return ' ' % self.username As you can see there are 2 new line. Importing flask_migrate and initializing migrate. Thats it you have to do for now.","title":"Code"},{"location":"flaskandorm/#how-to-create-migration","text":"","title":"How to create migration."},{"location":"flaskandorm/#initializing","text":"flask db init It will generate migrations folder.","title":"Initializing"},{"location":"flaskandorm/#generating-migration","text":"After making code changes in model. You can run the below command to generate migrtion flask db migrate Now there will be migrations generated and you can see those in migrations/versions folder.","title":"Generating Migration"},{"location":"flaskandorm/#applying-migration","text":"flask db upgrade","title":"Applying migration"},{"location":"flaskandorm/#downgrade-migration","text":"flask db downgrade version These are very basic of how you can keep track of your database migrations. You can read more about it. There are lot of complexities involve when it comes to migration with databases. So read about it properly before using it in production.","title":"Downgrade Migration"},{"location":"flaskdb/","text":"Python with database[MYSQL]. We have seen how to write flask applications that can serve basic requests. The next thing that we need to learn is how to save states in application. Till now we have only seen stateless applications. We will have a look at how we can connect to mysql using python mysql connectors. import mysql.connector mydb = mysql.connector.connect( host=\"localhost\", user=\"yourusername\", passwd=\"yourpassword\" ) print(mydb) This will print the connection that is created. Let try and create a table and insert some values in it. import mysql.connector mydb = mysql.connector.connect( host=\"localhost\", user=\"yourusername\", passwd=\"yourpassword\", database=\"testapp\" ) print(mydb) mycursor = mydb.cursor() mycursor.execute(\"CREATE TABLE customers (name VARCHAR(255), address VARCHAR(255))\") The above code will create table customers in testapp database. Lets insert values in this database. import mysql.connector mydb = mysql.connector.connect( host=\"localhost\", user=\"chowmean\", passwd=\"chowmean\", database=\"testapp\" ) print(mydb) mycursor = mydb.cursor() sql = \"INSERT INTO customers (name, address) VALUES (%s, %s)\" val = (\"John\", \"Highway 21\") mycursor.execute(sql, val) mydb.commit() print(mycursor.rowcount, \"record inserted.\") This will insert a row in table. Lets see how we can see the entry that is created right now. import mysql.connector mydb = mysql.connector.connect( host=\"localhost\", user=\"chowmean\", passwd=\"chowmean\", database=\"testapp\" ) mycursor = mydb.cursor() mycursor.execute(\"SELECT * FROM customers\") myresult = mycursor.fetchall() for x in myresult: print(x) This will print the data that is extracted from mysql.","title":"Python With Mysql"},{"location":"flaskdb/#python-with-databasemysql","text":"We have seen how to write flask applications that can serve basic requests. The next thing that we need to learn is how to save states in application. Till now we have only seen stateless applications. We will have a look at how we can connect to mysql using python mysql connectors. import mysql.connector mydb = mysql.connector.connect( host=\"localhost\", user=\"yourusername\", passwd=\"yourpassword\" ) print(mydb) This will print the connection that is created. Let try and create a table and insert some values in it. import mysql.connector mydb = mysql.connector.connect( host=\"localhost\", user=\"yourusername\", passwd=\"yourpassword\", database=\"testapp\" ) print(mydb) mycursor = mydb.cursor() mycursor.execute(\"CREATE TABLE customers (name VARCHAR(255), address VARCHAR(255))\") The above code will create table customers in testapp database. Lets insert values in this database. import mysql.connector mydb = mysql.connector.connect( host=\"localhost\", user=\"chowmean\", passwd=\"chowmean\", database=\"testapp\" ) print(mydb) mycursor = mydb.cursor() sql = \"INSERT INTO customers (name, address) VALUES (%s, %s)\" val = (\"John\", \"Highway 21\") mycursor.execute(sql, val) mydb.commit() print(mycursor.rowcount, \"record inserted.\") This will insert a row in table. Lets see how we can see the entry that is created right now. import mysql.connector mydb = mysql.connector.connect( host=\"localhost\", user=\"chowmean\", passwd=\"chowmean\", database=\"testapp\" ) mycursor = mydb.cursor() mycursor.execute(\"SELECT * FROM customers\") myresult = mycursor.fetchall() for x in myresult: print(x) This will print the data that is extracted from mysql.","title":"Python with database[MYSQL]."},{"location":"gil/","text":"GIL: Global Interpreter Lock Gil is a mutex lock in python which allows only one thread to execute at a time. This is why python is single threaded application. So if your program is simgle threaded python will perform as equal to any other language. But when it comes to multithreading and executing threads in parallel, it is not possible in python Why GIL? Python uses reference counting for memory management. What it does is it keeps track of all the variables that are created and wheather they are being used in the program now or not. If their is no reference for those variables. The python garbage collector kicks in and removes that variable from the heap. Now for this reference counting to work properly it need to be safe from race conditions. That is two threads try to change the reference count. If that happens that can lead to memory leak. This reference count can be kept safe by locking all the data structures that are shared accross the threads. Now if we lock these data structures. It means multiple locks will exist which can lead to problems like deadlock. Also it will decrease performance as aquisition and release of locks will happen quite frequently. GIL is a single lock which says that execution of any python byte code requires the interpreter lock. This prevents the above problem but makes the python single threaded. Why only GIL as solution? Python has been around since the days when operating systems did not have a concept of threads. Python was designed to be easy-to-use in order to make development quicker and more and more developers started using it. A lot of extensions were being written for the existing C libraries whose features were needed in Python. To prevent inconsistent changes, these C extensions required a thread-safe memory management which the GIL provided. The GIL is simple to implement and was easily added to Python. It provides a performance increase to single-threaded programs as only one lock needs to be managed. C libraries that were not thread-safe became easier to integrate. And these C extensions became one of the reasons why Python was readily adopted by different communities. Impacts? There are two kinds of multithreaded programs. I/O bound program : Programs that wait for input/output from user, file, database, network etc. These sometimes have to wait alot. CPU bound program : These programs are the one which does high computational tasks. We will see how python works in both these cases. In case of CPU bound programs the multithreading will not make any difference as the only one thread will execute. Infact you can see performance degrading for these cases. In case of IO bound process the multithreading will increase performance as IO bound process mostly wait for the input or output to be provided to them and they are in waiting state. Aquiring and releasing lock for these kind of process doesn't cause problem cause when one thread may got the output or input the others may still be waiting for the event. Work around? If you want to make use of all your core in pytho program instead of going for multithreading go for multiprocessing . Each process gets its own python interpretor this the GIL is applied on only that process and hence you can do lot of work in parallel. Read more about GIL here","title":"Global Interpreter Lock"},{"location":"gil/#gil-global-interpreter-lock","text":"Gil is a mutex lock in python which allows only one thread to execute at a time. This is why python is single threaded application. So if your program is simgle threaded python will perform as equal to any other language. But when it comes to multithreading and executing threads in parallel, it is not possible in python","title":"GIL: Global Interpreter Lock"},{"location":"gil/#why-gil","text":"Python uses reference counting for memory management. What it does is it keeps track of all the variables that are created and wheather they are being used in the program now or not. If their is no reference for those variables. The python garbage collector kicks in and removes that variable from the heap. Now for this reference counting to work properly it need to be safe from race conditions. That is two threads try to change the reference count. If that happens that can lead to memory leak. This reference count can be kept safe by locking all the data structures that are shared accross the threads. Now if we lock these data structures. It means multiple locks will exist which can lead to problems like deadlock. Also it will decrease performance as aquisition and release of locks will happen quite frequently. GIL is a single lock which says that execution of any python byte code requires the interpreter lock. This prevents the above problem but makes the python single threaded.","title":"Why GIL?"},{"location":"gil/#why-only-gil-as-solution","text":"Python has been around since the days when operating systems did not have a concept of threads. Python was designed to be easy-to-use in order to make development quicker and more and more developers started using it. A lot of extensions were being written for the existing C libraries whose features were needed in Python. To prevent inconsistent changes, these C extensions required a thread-safe memory management which the GIL provided. The GIL is simple to implement and was easily added to Python. It provides a performance increase to single-threaded programs as only one lock needs to be managed. C libraries that were not thread-safe became easier to integrate. And these C extensions became one of the reasons why Python was readily adopted by different communities.","title":"Why only GIL as solution?"},{"location":"gil/#impacts","text":"There are two kinds of multithreaded programs. I/O bound program : Programs that wait for input/output from user, file, database, network etc. These sometimes have to wait alot. CPU bound program : These programs are the one which does high computational tasks. We will see how python works in both these cases. In case of CPU bound programs the multithreading will not make any difference as the only one thread will execute. Infact you can see performance degrading for these cases. In case of IO bound process the multithreading will increase performance as IO bound process mostly wait for the input or output to be provided to them and they are in waiting state. Aquiring and releasing lock for these kind of process doesn't cause problem cause when one thread may got the output or input the others may still be waiting for the event.","title":"Impacts?"},{"location":"gil/#work-around","text":"If you want to make use of all your core in pytho program instead of going for multithreading go for multiprocessing . Each process gets its own python interpretor this the GIL is applied on only that process and hence you can do lot of work in parallel. Read more about GIL here","title":"Work around?"},{"location":"internals/","text":"Python Internals Compiler: Definition: A compiler is a computer program that transforms (translates) source code of a programming language (the source language) into another computer language (the target language). In most cases compilers are used to transform source code into executable program, i.e. they translate code from high-level programming languages into low (or lower) level languages, mostly assembly or machine code. Ex: 1. Java 2. C++ 3. C# Interpreter Definition: An interpreter is a computer program that executes instructions written in a programming language. Translation occurs at the same time as the program is being executed. It can either execute the source code directly or translate the source code in a first step into a more efficient representation and execute this code Ex: 1. java script 2. Python How Python runs? Have you ever thought how the Python code is actually executed by the Python interpreter? What steps are carried out to generate the final output of your Python script? This article answers all these questions in a simplistic manner! The interpreter Interpreter is nothing but a software which can run your Python scripts. Interestingly, it can be implemented in any programming language! CPython is the default interpreter for Python which is written in C programming language. Jython is another popular implementation of python interpreter written using Java programming language. Programmer\u2019s view of interpreter If you have been coding in Python for sometime, you must have heard about the interpreter at least a few times. From a programmer\u2019s perspective, an interpreter is simply a software which executes the source code line by line. For most of the Python programmers, an interpreter is like a black box. Python\u2019s view of interpreter Now, let us scan through the python interpreter and try to understand how it works. Have a look at the diagram shown below: I hope you didn\u2019t get amazed to see a compiler inside an interpreter! From the figure above, it can be inferred that interpreter is made up of two parts: compiler virtual machine What does compiler do? Compiler compiles your source code (the statements in your file) into a format known as byte code. Compilation is simply a translation step! Byte code is a: lower level, platform independent, efficient and intermediate representation of your source code! Roughly, each of your source statements is translated into a group of byte code instructions. The process of compilation in CPython interpreter\u2019s compiler can be divided into 4 main parts: Parse source code into a parse tree: Based on grammar rules of Python programming language, the source code is converted to a parse tree. Every node of the parse tree contains a part of your code. Consider a simple arithmetic expression: 14 + 2 * 3 - 6 / 2 The parse tree for above expression looks like this: Transform parse tree into an Abstract Syntax Tree: The abstract syntax tree (AST) is a high-level representation of the program structure. Each node of the tree denotes a construct occurring in the source code. The syntax is \u201cabstract\u201d in not representing every detail appearing in the real syntax.Consider the AST shown below for the parse tree example discussed above: Transform AST into a Control Flow Graph: A control flow graph is a directed graph that models the flow of a program using basic blocks. Each block contains the bytecode representation of program code inside it. Byte Code generation from CFG: CFGs are usually one step away from final code output. Code is directly generated from the basic blocks by doing a post-order depth-first search on the CFG following the edges. This byte code translation is performed to speed up the execution\u2014byte code can be run much quicker than the original source code statements. What does Virtual Machine do? As soon as source code gets converted to byte code, it is fed into PVM (Python Virtual Machine). It\u2019s just a big loop that iterates through your byte code instructions, one by one, to carry out their operations. The PVM is the runtime engine of Python ; it\u2019s always present as part of the Python system, and is the component that truly runs your scripts. Technically, it\u2019s just the last step of what is called the Python interpreter. Lastly, here are a interesting points: PyPy is an implementation of Python which does not use an interpreter! It is implemented using something called just-in-time compiler! Interestingly, it often runs faster than the standard implementation of Python, CPython. Whenever a Python script is executed, the byte code is generated in memory and simply discarded when program exits. But, if a Python module is imported, a .pyc file for the module is generated which contains its Byte code. Thus, when the module is imported next time, the byte code from .pyc file is used, hence skipping the compilation step! see compiled files: python -m py_compile hello.py Question: when we update source code of imported module, how does interpreter picks up that updated code?","title":"Python internals"},{"location":"internals/#python-internals","text":"","title":"Python Internals"},{"location":"internals/#compiler","text":"Definition: A compiler is a computer program that transforms (translates) source code of a programming language (the source language) into another computer language (the target language). In most cases compilers are used to transform source code into executable program, i.e. they translate code from high-level programming languages into low (or lower) level languages, mostly assembly or machine code. Ex: 1. Java 2. C++ 3. C#","title":"Compiler:"},{"location":"internals/#interpreter","text":"Definition: An interpreter is a computer program that executes instructions written in a programming language. Translation occurs at the same time as the program is being executed. It can either execute the source code directly or translate the source code in a first step into a more efficient representation and execute this code Ex: 1. java script 2. Python","title":"Interpreter"},{"location":"internals/#how-python-runs","text":"Have you ever thought how the Python code is actually executed by the Python interpreter? What steps are carried out to generate the final output of your Python script? This article answers all these questions in a simplistic manner!","title":"How Python runs?"},{"location":"internals/#the-interpreter","text":"Interpreter is nothing but a software which can run your Python scripts. Interestingly, it can be implemented in any programming language! CPython is the default interpreter for Python which is written in C programming language. Jython is another popular implementation of python interpreter written using Java programming language.","title":"The interpreter"},{"location":"internals/#programmers-view-of-interpreter","text":"If you have been coding in Python for sometime, you must have heard about the interpreter at least a few times. From a programmer\u2019s perspective, an interpreter is simply a software which executes the source code line by line. For most of the Python programmers, an interpreter is like a black box.","title":"Programmer\u2019s view of interpreter"},{"location":"internals/#pythons-view-of-interpreter","text":"Now, let us scan through the python interpreter and try to understand how it works. Have a look at the diagram shown below: I hope you didn\u2019t get amazed to see a compiler inside an interpreter! From the figure above, it can be inferred that interpreter is made up of two parts: compiler virtual machine What does compiler do? Compiler compiles your source code (the statements in your file) into a format known as byte code. Compilation is simply a translation step! Byte code is a: lower level, platform independent, efficient and intermediate representation of your source code! Roughly, each of your source statements is translated into a group of byte code instructions. The process of compilation in CPython interpreter\u2019s compiler can be divided into 4 main parts: Parse source code into a parse tree: Based on grammar rules of Python programming language, the source code is converted to a parse tree. Every node of the parse tree contains a part of your code. Consider a simple arithmetic expression: 14 + 2 * 3 - 6 / 2 The parse tree for above expression looks like this: Transform parse tree into an Abstract Syntax Tree: The abstract syntax tree (AST) is a high-level representation of the program structure. Each node of the tree denotes a construct occurring in the source code. The syntax is \u201cabstract\u201d in not representing every detail appearing in the real syntax.Consider the AST shown below for the parse tree example discussed above: Transform AST into a Control Flow Graph: A control flow graph is a directed graph that models the flow of a program using basic blocks. Each block contains the bytecode representation of program code inside it. Byte Code generation from CFG: CFGs are usually one step away from final code output. Code is directly generated from the basic blocks by doing a post-order depth-first search on the CFG following the edges. This byte code translation is performed to speed up the execution\u2014byte code can be run much quicker than the original source code statements.","title":"Python\u2019s view of interpreter"},{"location":"internals/#what-does-virtual-machine-do","text":"As soon as source code gets converted to byte code, it is fed into PVM (Python Virtual Machine). It\u2019s just a big loop that iterates through your byte code instructions, one by one, to carry out their operations. The PVM is the runtime engine of Python ; it\u2019s always present as part of the Python system, and is the component that truly runs your scripts. Technically, it\u2019s just the last step of what is called the Python interpreter.","title":"What does Virtual Machine do?"},{"location":"internals/#lastly-here-are-a-interesting-points","text":"PyPy is an implementation of Python which does not use an interpreter! It is implemented using something called just-in-time compiler! Interestingly, it often runs faster than the standard implementation of Python, CPython. Whenever a Python script is executed, the byte code is generated in memory and simply discarded when program exits. But, if a Python module is imported, a .pyc file for the module is generated which contains its Byte code. Thus, when the module is imported next time, the byte code from .pyc file is used, hence skipping the compilation step!","title":"Lastly, here are a interesting points:"},{"location":"internals/#see-compiled-files","text":"python -m py_compile hello.py","title":"see compiled files:"},{"location":"internals/#question","text":"when we update source code of imported module, how does interpreter picks up that updated code?","title":"Question:"},{"location":"logging/","text":"Logging In this section we will have a look how we can do logging in python applications. We will also have a look what we should and and what we should not log. Logging is important but extra logging can cause a lot of issue. Issues like latency, extra disk space usage etc. For logging in python we use logging module of python. Have a look at the code below import logging logging.debug('This is a debug') logging.info('This is an info') logging.warning('This is a warning') logging.error('This is an error') logging.critical('This is a critical') It is very basic to do logging in python. Configurations Below are few of the basic configs that will be useful for you. level: Sets the log level filename: This specifies the file. filemode: If filename is given, the file is opened in this mode. The default is a, which means append. format: This is the format of the log message. Lets use this in our applications import click import requests import json import logging logging.basicConfig(format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S', filename='app.logs', level=logging.DEBUG) @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') def get_projects(username): logging.debug(\"Contacting github for repos.\") a = requests.get(\"https://api.github.com/users/\"+username+\"/repos\") logging.debug(\"Github data received.\") data = json.loads(a.content) return data if __name__ == '__main__': logging.debug(\"Initilizing application.\") get_projects() Now when you will run this you can see the logs in app.logs file. Now if you want these logging to be configurable you can simply get these as options like below. import click import requests import json import logging log_levels={ \"warn\": logging.WARNING, \"info\": logging.INFO, \"error\": logging.ERROR, \"debug\": logging.DEBUG, \"critical\": logging.CRITICAL } @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') @click.option('--logfile', prompt='Log file name', help='File to which log', default=\"app.logs\") @click.option('--loglevel', prompt='Log level', help='Log level to use.', default=\"warn\") def get_projects(username, logfile, loglevel): logging.basicConfig(format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S', filename=logfile, level=log_levels[loglevel]) logging.debug(\"Contacting github for repos.\") a = requests.get(\"https://api.github.com/users/\"+username+\"/repos\") logging.debug(\"Github data received.\") data = json.loads(a.content) return data if __name__ == '__main__': get_projects() Rotating Logs: Python\u2019s logging module has lots of options. In this article, we will looks at the logging module\u2019s ability to create Rotating Logs. Python supports two types of rotating logs: 1) Rotate logs based on size (RotatingFileHandler) 2) Rotate the logs based on some time interval (TimedRotatingFileHandler) The RotatingFileHandler: It rotates the logs based on the size of the log file. We can specify the size with \"maxBytes\" parameter. The handler will close the file and silently open a new one. If you pass in a number for the backupCount parameter, then it will append \u201c.1\u201d, \u201c.2\u201d, etcetera to the end of the log files. Let\u2019s take a look at a simple example: import logging import time from logging.handlers import RotatingFileHandler def create_rotating_log(path): \"\"\" Creates a rotating log based on size \"\"\" logger = logging.getLogger(\"Rotating Log\") logger.setLevel(logging.INFO) handler = RotatingFileHandler(path, maxBytes=20, backupCount=5) logger.addHandler(handler) for i in range(10): logger.info(\"This is test log line %s\" % i) time.sleep(1.5) if __name__ == \"__main__\": log_file = \"test.log\" create_rotating_log(log_file) Understanding above code in steps: we create a log file with a logging level of INFO. Then we set up the handler to rotate the log whenever the log file is 20 bytes in length we create a loop that will create 10 lines in our log file with a sleep in between each call to log. The TimedRotatingFileHandler: The TimedRotatingFileHandler allows the developer to create a rotating log based on how much time has elapsed. You can set it to rotate the log on the following time conditions: second (s) minute (m) hour (h) day (d) w0-w6 (weekday, 0=Monday) midnight Example: import logging import time from logging.handlers import TimedRotatingFileHandler def create_timed_rotating_log(path): logger = logging.getLogger(\"Rotating Log\") logger.setLevel(logging.INFO) handler = TimedRotatingFileHandler(path, when=\"m\", interval=1, backupCount=5) logger.addHandler(handler) for i in range(6): logger.info(\"This is a test!\") time.sleep(75) if __name__ == \"__main__\": log_file = \"timed_test.log\" create_timed_rotating_log(log_file)","title":"Logging in application"},{"location":"logging/#logging","text":"In this section we will have a look how we can do logging in python applications. We will also have a look what we should and and what we should not log. Logging is important but extra logging can cause a lot of issue. Issues like latency, extra disk space usage etc. For logging in python we use logging module of python. Have a look at the code below import logging logging.debug('This is a debug') logging.info('This is an info') logging.warning('This is a warning') logging.error('This is an error') logging.critical('This is a critical') It is very basic to do logging in python.","title":"Logging"},{"location":"logging/#configurations","text":"Below are few of the basic configs that will be useful for you. level: Sets the log level filename: This specifies the file. filemode: If filename is given, the file is opened in this mode. The default is a, which means append. format: This is the format of the log message. Lets use this in our applications import click import requests import json import logging logging.basicConfig(format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S', filename='app.logs', level=logging.DEBUG) @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') def get_projects(username): logging.debug(\"Contacting github for repos.\") a = requests.get(\"https://api.github.com/users/\"+username+\"/repos\") logging.debug(\"Github data received.\") data = json.loads(a.content) return data if __name__ == '__main__': logging.debug(\"Initilizing application.\") get_projects() Now when you will run this you can see the logs in app.logs file. Now if you want these logging to be configurable you can simply get these as options like below. import click import requests import json import logging log_levels={ \"warn\": logging.WARNING, \"info\": logging.INFO, \"error\": logging.ERROR, \"debug\": logging.DEBUG, \"critical\": logging.CRITICAL } @click.command() @click.option('--username', prompt='Github username', help='Github username to get repo details.') @click.option('--logfile', prompt='Log file name', help='File to which log', default=\"app.logs\") @click.option('--loglevel', prompt='Log level', help='Log level to use.', default=\"warn\") def get_projects(username, logfile, loglevel): logging.basicConfig(format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S', filename=logfile, level=log_levels[loglevel]) logging.debug(\"Contacting github for repos.\") a = requests.get(\"https://api.github.com/users/\"+username+\"/repos\") logging.debug(\"Github data received.\") data = json.loads(a.content) return data if __name__ == '__main__': get_projects()","title":"Configurations"},{"location":"logging/#rotating-logs","text":"Python\u2019s logging module has lots of options. In this article, we will looks at the logging module\u2019s ability to create Rotating Logs. Python supports two types of rotating logs: 1) Rotate logs based on size (RotatingFileHandler) 2) Rotate the logs based on some time interval (TimedRotatingFileHandler)","title":"Rotating Logs:"},{"location":"logging/#the-rotatingfilehandler","text":"It rotates the logs based on the size of the log file. We can specify the size with \"maxBytes\" parameter. The handler will close the file and silently open a new one. If you pass in a number for the backupCount parameter, then it will append \u201c.1\u201d, \u201c.2\u201d, etcetera to the end of the log files. Let\u2019s take a look at a simple example: import logging import time from logging.handlers import RotatingFileHandler def create_rotating_log(path): \"\"\" Creates a rotating log based on size \"\"\" logger = logging.getLogger(\"Rotating Log\") logger.setLevel(logging.INFO) handler = RotatingFileHandler(path, maxBytes=20, backupCount=5) logger.addHandler(handler) for i in range(10): logger.info(\"This is test log line %s\" % i) time.sleep(1.5) if __name__ == \"__main__\": log_file = \"test.log\" create_rotating_log(log_file)","title":"The RotatingFileHandler:"},{"location":"logging/#understanding-above-code-in-steps","text":"we create a log file with a logging level of INFO. Then we set up the handler to rotate the log whenever the log file is 20 bytes in length we create a loop that will create 10 lines in our log file with a sleep in between each call to log.","title":"Understanding above code in steps:"},{"location":"logging/#the-timedrotatingfilehandler","text":"The TimedRotatingFileHandler allows the developer to create a rotating log based on how much time has elapsed. You can set it to rotate the log on the following time conditions: second (s) minute (m) hour (h) day (d) w0-w6 (weekday, 0=Monday) midnight","title":"The TimedRotatingFileHandler:"},{"location":"logging/#example","text":"import logging import time from logging.handlers import TimedRotatingFileHandler def create_timed_rotating_log(path): logger = logging.getLogger(\"Rotating Log\") logger.setLevel(logging.INFO) handler = TimedRotatingFileHandler(path, when=\"m\", interval=1, backupCount=5) logger.addHandler(handler) for i in range(6): logger.info(\"This is a test!\") time.sleep(75) if __name__ == \"__main__\": log_file = \"timed_test.log\" create_timed_rotating_log(log_file)","title":"Example:"},{"location":"mem/","text":"Memory Management This concept deals with the way python manages memory, how it assigns memory, how it cleans memory and garbage collect. An OS-specific virtual memory manager carves out a chunk of memory for the Python process. Python uses a portion of the memory for internal use and non-object memory. The other portion is dedicated to object storage (your int, dict, and the like). Heaps and Stack These are the two major datastructure that is being used by any programming language for running the programs. Heaps Heaps are used for stroing data and objects in memory that are being referenced from stacks. Stacks These are used for mainly function calls and variables in the a particular scope. Garbage Collection Python interpretor keeps the reference count of all the variables, if reference count of any variable becomes 0. That variable is garbage collected. If you want to read more about it read here memory management in python","title":"Memory Management"},{"location":"mem/#memory-management","text":"This concept deals with the way python manages memory, how it assigns memory, how it cleans memory and garbage collect. An OS-specific virtual memory manager carves out a chunk of memory for the Python process. Python uses a portion of the memory for internal use and non-object memory. The other portion is dedicated to object storage (your int, dict, and the like).","title":"Memory Management"},{"location":"mem/#heaps-and-stack","text":"These are the two major datastructure that is being used by any programming language for running the programs.","title":"Heaps and Stack"},{"location":"mem/#heaps","text":"Heaps are used for stroing data and objects in memory that are being referenced from stacks.","title":"Heaps"},{"location":"mem/#stacks","text":"These are used for mainly function calls and variables in the a particular scope.","title":"Stacks"},{"location":"mem/#garbage-collection","text":"Python interpretor keeps the reference count of all the variables, if reference count of any variable becomes 0. That variable is garbage collected. If you want to read more about it read here memory management in python","title":"Garbage Collection"},{"location":"metrics/","text":"Exporting Metrics Metrics are very important to keep track of how your software is working. This will help you in keeping check on any unwanted things that went to production and impacted it. One of the most important tools for metrics is prometheus that is very widely used by companies. We will try expose metrics for prometheus using python prometheus client. Installation pip install prometheus_client Code from prometheus_client import start_http_server, Summary import random import time # Create a metric to track time spent and requests made. REQUEST_TIME = Summary('request_processing_seconds', 'Time spent processing request') # Decorate function with metric. @REQUEST_TIME.time() def process_request(t): \"\"\"A dummy function that takes some time.\"\"\" time.sleep(t) if __name__ == '__main__': # Start up the server to expose the metrics. start_http_server(9000) # Generate some requests. while True: process_request(random.random()) This will run a server on port 9000 and export metrics that prometheus will be able to consume. Prometheus exporter with flask. You can do the same with you application written in flask using different client present for flask. https://pypi.org/project/prometheus-flask-exporter/ Read about it create an application with metrics. Ping me if you are stuck.","title":"Exposing metrics with python"},{"location":"metrics/#exporting-metrics","text":"Metrics are very important to keep track of how your software is working. This will help you in keeping check on any unwanted things that went to production and impacted it. One of the most important tools for metrics is prometheus that is very widely used by companies. We will try expose metrics for prometheus using python prometheus client.","title":"Exporting Metrics"},{"location":"metrics/#installation","text":"pip install prometheus_client","title":"Installation"},{"location":"metrics/#code","text":"from prometheus_client import start_http_server, Summary import random import time # Create a metric to track time spent and requests made. REQUEST_TIME = Summary('request_processing_seconds', 'Time spent processing request') # Decorate function with metric. @REQUEST_TIME.time() def process_request(t): \"\"\"A dummy function that takes some time.\"\"\" time.sleep(t) if __name__ == '__main__': # Start up the server to expose the metrics. start_http_server(9000) # Generate some requests. while True: process_request(random.random()) This will run a server on port 9000 and export metrics that prometheus will be able to consume.","title":"Code"},{"location":"metrics/#prometheus-exporter-with-flask","text":"You can do the same with you application written in flask using different client present for flask. https://pypi.org/project/prometheus-flask-exporter/ Read about it create an application with metrics. Ping me if you are stuck.","title":"Prometheus exporter with flask."},{"location":"oops/","text":"Concept of Object Oriented Programming Objects Everything in python are objects. Even if you initialize a variable with 1. 1 is a object of type int. Classes Classes are combination of variables and functions. Classes define a type of any object. An example of class in below class employee(): __phone_number=\"\" def __init__(name, age): self.name = name self.age = age def get_age(): return self.age def set_age(value): self.age = value def get_name(): return self.name def set_phone(value): self.__phone_number = value This is an example of class, Here we have private variable phone_number, which cannot be ediited by anyone else but functions inside the class. __init () is a constructor which is used to initialize the class. Inheritance The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important feature of Object Oriented Programming. Sub Class: The class that inherits properties from another class is called Sub class or Derived Class. Super Class: The class whose properties are inherited by sub class is called Base Class or Super class. class Employee(): __phone_number=\"0000000000\" def __init__(self, name, age): self.name = name self.age = age def get_age(self): return self.age def set_age(self,value): self.age = value def get_name(self): return self.name def set_phone(self,value): self.__phone_number = value def get_phone(self): return self.__phone_number def set_phone(self, value): self.__phone_number = value class VIP(Employee): def get_phone(self): return \"************\" def get_vip_access(self): return \"access_granted\" if __name__ == '__main__': #Simple Employee emp = Employee(\"gaurav\", 12) print(emp.get_phone()) emp.set_phone(\"89628363**\") print(emp.get_phone()) #Vip employee inherting employee properties vip = VIP(\"Venky\", 54) #Overriden method hides phone number print(vip.get_phone()) #Extra added function. print(vip.get_vip_access()) #This function calls the inherited method. print(vip.get_name()) Encapsulation Encapsulation is a way to hide some of the variables of the class to be not accessible from outside the class. In other languages there are class members like private and protected but in python there is no such concept. Instead you can define a private class member like this class Employee(): __phone_number=\"0000000000\" Here __phone_number is a private class member and cannot be accessible from outside the class. You cannot access this variable like below. a = Employee() a.__phone_number To access these variables you have to write getter and setter function for these. Which can do the basic checks before setting the variables. class Employee(): __phone_number=\"0000000000\" def get_phone(self): return self.__phone_number def set_phone(self, value): self.__phone_number = value Use of Encapsulation? Say you have a class User where you have age and password class members. Here you will not want anyone outside the class to see password. Also you want to apply some check before setting the password. This can be done using this. Look at the code below. class User(): __password=\"\" def __init__(self, name, age): self.name = name self.age = age def set_password(password): if password_check(password): self.__password=password Polymorphism Polymorphism means having many forms. In programming it means that same function names can be used for different types of work. def add(x, y, z = 0): return x + y+z # Driver code print(add(2, 3)) print(add(2, 3, 4)) Here function add has two forms. One is when it takes two arguements where the third one itself is 0. Other is when it takes 3 variables. This is very basic example of polymorphism","title":"Object Oriented Programming"},{"location":"oops/#concept-of-object-oriented-programming","text":"","title":"Concept of Object Oriented Programming"},{"location":"oops/#objects","text":"Everything in python are objects. Even if you initialize a variable with 1. 1 is a object of type int.","title":"Objects"},{"location":"oops/#classes","text":"Classes are combination of variables and functions. Classes define a type of any object. An example of class in below class employee(): __phone_number=\"\" def __init__(name, age): self.name = name self.age = age def get_age(): return self.age def set_age(value): self.age = value def get_name(): return self.name def set_phone(value): self.__phone_number = value This is an example of class, Here we have private variable phone_number, which cannot be ediited by anyone else but functions inside the class. __init () is a constructor which is used to initialize the class.","title":"Classes"},{"location":"oops/#inheritance","text":"The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important feature of Object Oriented Programming. Sub Class: The class that inherits properties from another class is called Sub class or Derived Class. Super Class: The class whose properties are inherited by sub class is called Base Class or Super class. class Employee(): __phone_number=\"0000000000\" def __init__(self, name, age): self.name = name self.age = age def get_age(self): return self.age def set_age(self,value): self.age = value def get_name(self): return self.name def set_phone(self,value): self.__phone_number = value def get_phone(self): return self.__phone_number def set_phone(self, value): self.__phone_number = value class VIP(Employee): def get_phone(self): return \"************\" def get_vip_access(self): return \"access_granted\" if __name__ == '__main__': #Simple Employee emp = Employee(\"gaurav\", 12) print(emp.get_phone()) emp.set_phone(\"89628363**\") print(emp.get_phone()) #Vip employee inherting employee properties vip = VIP(\"Venky\", 54) #Overriden method hides phone number print(vip.get_phone()) #Extra added function. print(vip.get_vip_access()) #This function calls the inherited method. print(vip.get_name())","title":"Inheritance"},{"location":"oops/#encapsulation","text":"Encapsulation is a way to hide some of the variables of the class to be not accessible from outside the class. In other languages there are class members like private and protected but in python there is no such concept. Instead you can define a private class member like this class Employee(): __phone_number=\"0000000000\" Here __phone_number is a private class member and cannot be accessible from outside the class. You cannot access this variable like below. a = Employee() a.__phone_number To access these variables you have to write getter and setter function for these. Which can do the basic checks before setting the variables. class Employee(): __phone_number=\"0000000000\" def get_phone(self): return self.__phone_number def set_phone(self, value): self.__phone_number = value","title":"Encapsulation"},{"location":"oops/#use-of-encapsulation","text":"Say you have a class User where you have age and password class members. Here you will not want anyone outside the class to see password. Also you want to apply some check before setting the password. This can be done using this. Look at the code below. class User(): __password=\"\" def __init__(self, name, age): self.name = name self.age = age def set_password(password): if password_check(password): self.__password=password","title":"Use of Encapsulation?"},{"location":"oops/#polymorphism","text":"Polymorphism means having many forms. In programming it means that same function names can be used for different types of work. def add(x, y, z = 0): return x + y+z # Driver code print(add(2, 3)) print(add(2, 3, 4)) Here function add has two forms. One is when it takes two arguements where the third one itself is 0. Other is when it takes 3 variables. This is very basic example of polymorphism","title":"Polymorphism"},{"location":"package/","text":"Creating a python package. For creating a python file you need below steps. Application Structure Lets say our app structure is like below firstapp --pack.py --__init__.py setup.py README.md Lets say pack.py contains below code def say_hello(): print(\"hello\") Setup file You need to create a setup.py file which will contain information about the package. import setuptools with open(\"README.md\", \"r\") as fh: long_description = fh.read() setuptools.setup( name='firstapp', version='0.1', scripts=['firstapp/pack.py'] , author=\"chowmean\", author_email=\"gaurav.dev.iiitm@gmail.com\", description=\"Test package creation package\", long_description=\"long_description\", long_description_content_type=\"text/markdown\", url=\"https://gitlab.com/chowmean\", packages=setuptools.find_packages(), classifiers=[ \"Programming Language :: Python :: 3\", \"License :: OSI Approved :: MIT License\", \"Operating System :: OS Independent\", ], ) Other files init file will be empty and README.md you can put about the project. After this you need to make sure setuptools is installed on you environment. Then run this below command. Build package python setup.py bdist_wheel This will create your python package and your package will be present in /dist directory. To install this package you can simply use the below command. Install local package python -m pip install firstapp-0.1-py2-none-any.whl This will install firstapp in your python environment. You can use it like below. Using Installed package. from firstapp import pack pack.say_hello() This will print the Hello from the package. This was very basic of how you can create a python pakcage. The advanced thing that you can try is installing all the dependent packages of your application at the time of application installation.","title":"Creating a python package"},{"location":"package/#creating-a-python-package","text":"For creating a python file you need below steps.","title":"Creating a python package."},{"location":"package/#application-structure","text":"Lets say our app structure is like below firstapp --pack.py --__init__.py setup.py README.md Lets say pack.py contains below code def say_hello(): print(\"hello\")","title":"Application Structure"},{"location":"package/#setup-file","text":"You need to create a setup.py file which will contain information about the package. import setuptools with open(\"README.md\", \"r\") as fh: long_description = fh.read() setuptools.setup( name='firstapp', version='0.1', scripts=['firstapp/pack.py'] , author=\"chowmean\", author_email=\"gaurav.dev.iiitm@gmail.com\", description=\"Test package creation package\", long_description=\"long_description\", long_description_content_type=\"text/markdown\", url=\"https://gitlab.com/chowmean\", packages=setuptools.find_packages(), classifiers=[ \"Programming Language :: Python :: 3\", \"License :: OSI Approved :: MIT License\", \"Operating System :: OS Independent\", ], )","title":"Setup file"},{"location":"package/#other-files","text":"init file will be empty and README.md you can put about the project. After this you need to make sure setuptools is installed on you environment. Then run this below command.","title":"Other files"},{"location":"package/#build-package","text":"python setup.py bdist_wheel This will create your python package and your package will be present in /dist directory. To install this package you can simply use the below command.","title":"Build package"},{"location":"package/#install-local-package","text":"python -m pip install firstapp-0.1-py2-none-any.whl This will install firstapp in your python environment. You can use it like below.","title":"Install local package"},{"location":"package/#using-installed-package","text":"from firstapp import pack pack.say_hello() This will print the Hello from the package. This was very basic of how you can create a python pakcage. The advanced thing that you can try is installing all the dependent packages of your application at the time of application installation.","title":"Using Installed package."},{"location":"syntax/","text":"About python Blocks in python While in most of the langauges blocks are defined using brackets like {}, (), [] but in python blocks are defined using spaces that is the piece of code that has the same spaces from the start of line belong to that contiguous block. Example: for(int i=0;i < =20;i++){ //block start console.log(i) } //block end This is javascript example of printing number from one to 20 i=0 while i < =20: #block start print(i) #block end This is python style of the same. Why are Blocks important? Blocks are important because variables scoping depends a lot on them. Variable defined inside a block will only be accessible from inside the block only. Variables Python Variable Name Rules Must begin with a letter (a - z, A - B) or underscore (_) Other characters can be letters, numbers or _ Case Sensitive Can be any (reasonable) length There are some reserved words which you cannot use as a variable name because Python uses them for other things. Good Variable Name Choose meaningful name instead of short name. roll_no is better than rn. Maintain the length of a variable name. Roll_no_of_a-student is too long? Be consistent; roll_no or RollNo Begin a variable name with an underscore(_) character for a special case. Since python in not static typed language you do not need to define the type of variables. Loops For i=0 for i < 10: print(i) i++ While i=0 while i < 10: print(i) i++ Loop through objects a = [1,2,3,4,5,6,7] for i in a: print(i) a=[{\"name\":\"qw\"},{\"name\":\"qwe\"}] for i in a: print(a[\"name\"]) Functions def function_add(var1, var2, var3): do_some_work return var1+var2+var3 Default arguements in functions def function_default_arg(var1, var2, var3=10): return var1+var2+var3 Here if no value is specified for var3 it will be 10 by default so you can call it like below. It also shows us a form of polymorphism which we will see later in this tutorial.","title":"Python Syntax"},{"location":"syntax/#about-python","text":"","title":"About python"},{"location":"syntax/#blocks-in-python","text":"While in most of the langauges blocks are defined using brackets like {}, (), [] but in python blocks are defined using spaces that is the piece of code that has the same spaces from the start of line belong to that contiguous block. Example: for(int i=0;i < =20;i++){ //block start console.log(i) } //block end This is javascript example of printing number from one to 20 i=0 while i < =20: #block start print(i) #block end This is python style of the same.","title":"Blocks in python"},{"location":"syntax/#why-are-blocks-important","text":"Blocks are important because variables scoping depends a lot on them. Variable defined inside a block will only be accessible from inside the block only.","title":"Why are Blocks important?"},{"location":"syntax/#variables","text":"","title":"Variables"},{"location":"syntax/#python-variable-name-rules","text":"Must begin with a letter (a - z, A - B) or underscore (_) Other characters can be letters, numbers or _ Case Sensitive Can be any (reasonable) length There are some reserved words which you cannot use as a variable name because Python uses them for other things.","title":"Python Variable Name Rules"},{"location":"syntax/#good-variable-name","text":"Choose meaningful name instead of short name. roll_no is better than rn. Maintain the length of a variable name. Roll_no_of_a-student is too long? Be consistent; roll_no or RollNo Begin a variable name with an underscore(_) character for a special case. Since python in not static typed language you do not need to define the type of variables.","title":"Good Variable Name"},{"location":"syntax/#loops","text":"","title":"Loops"},{"location":"syntax/#for","text":"i=0 for i < 10: print(i) i++","title":"For"},{"location":"syntax/#while","text":"i=0 while i < 10: print(i) i++","title":"While"},{"location":"syntax/#loop-through-objects","text":"a = [1,2,3,4,5,6,7] for i in a: print(i) a=[{\"name\":\"qw\"},{\"name\":\"qwe\"}] for i in a: print(a[\"name\"])","title":"Loop through objects"},{"location":"syntax/#functions","text":"def function_add(var1, var2, var3): do_some_work return var1+var2+var3","title":"Functions"},{"location":"syntax/#default-arguements-in-functions","text":"def function_default_arg(var1, var2, var3=10): return var1+var2+var3 Here if no value is specified for var3 it will be 10 by default so you can call it like below. It also shows us a form of polymorphism which we will see later in this tutorial.","title":"Default arguements in functions"},{"location":"tooling/","text":"To begin with python tooling, lets first see what these tools are used for. Starting a project To start any project it is always recommended to create the project in its own environment. This means that anything that is installed for python at global level will not affect this env anf vice versa. How to start development? VirutalENV: Install virtualenv sudo apt-get install virtualenv After installation activate it. virtualenv env_name -m python3 This will create an env for python 3 and you can start working inside it. Keep in mind that you have to activate the env before running your code to make it work. Activate env: sourve env_name/bin/activate Now you can install any packages that you want to use in your python program. Deactivate env: deactivate Pep8 formatting. Pep8 is the formatting style that defines how you should format your python program. How you should name your variables and more such conventions. Pep8 is highly recommende for anyone who want to work with opensource community. Dependency Management For dependency management in python we use pip. It is used for installing packages. You can have a file naming requirements.txt which will have all the packages that you need to install along with the version that you want to install. How to install python package: pip install package_name How to install using requirements.txt pip install -r requirements.txt Editor? Pycharm is very good for python but if you are power user of sublime that will be awesome.","title":"Basic Tooling for Python"},{"location":"tooling/#starting-a-project","text":"To start any project it is always recommended to create the project in its own environment. This means that anything that is installed for python at global level will not affect this env anf vice versa.","title":"Starting a project"},{"location":"tooling/#how-to-start-development","text":"","title":"How to start development?"},{"location":"tooling/#virutalenv","text":"Install virtualenv sudo apt-get install virtualenv After installation activate it. virtualenv env_name -m python3 This will create an env for python 3 and you can start working inside it. Keep in mind that you have to activate the env before running your code to make it work. Activate env: sourve env_name/bin/activate Now you can install any packages that you want to use in your python program. Deactivate env: deactivate","title":"VirutalENV:"},{"location":"tooling/#pep8-formatting","text":"Pep8 is the formatting style that defines how you should format your python program. How you should name your variables and more such conventions. Pep8 is highly recommende for anyone who want to work with opensource community.","title":"Pep8 formatting."},{"location":"tooling/#dependency-management","text":"For dependency management in python we use pip. It is used for installing packages. You can have a file naming requirements.txt which will have all the packages that you need to install along with the version that you want to install.","title":"Dependency Management"},{"location":"tooling/#how-to-install-python-package","text":"pip install package_name","title":"How to install python package:"},{"location":"tooling/#how-to-install-using-requirementstxt","text":"pip install -r requirements.txt","title":"How to install using requirements.txt"},{"location":"tooling/#editor","text":"Pycharm is very good for python but if you are power user of sublime that will be awesome.","title":"Editor?"}]}